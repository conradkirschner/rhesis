// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { addBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPost, addEmojiReactionCommentsCommentIdEmojiEmojiPost, addMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPost, assignTagToEntityTagsEntityTypeEntityIdPost, associateTestsWithTestSetTestSetsTestSetIdAssociatePost, authCallbackAuthCallbackGet, bulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePost, createBehaviorBehaviorsPost, createCategoryCategoriesPost, createChatCompletionEndpointServicesChatCompletionsPost, createCommentCommentsPost, createDemographicDemographicsPost, createDimensionDimensionsPost, createEndpointEndpointsPost, createMetricMetricsPost, createModelModelsPost, createOrganizationOrganizationsPost, createProjectProjectsPost, createPromptPromptsPost, createPromptTemplatePromptTemplatesPost, createResponsePatternResponsePatternsPost, createRiskRisksPost, createSourceSourcesPost, createStatusStatusesPost, createTagTagsPost, createTaskTasksPost, createTestConfigurationTestConfigurationsPost, createTestContextTestContextsPost, createTestResultTestResultsPost, createTestRunTestRunsPost, createTestsBulkTestsBulkPost, createTestSetBulkTestSetsBulkPost, createTestSetTestSetsPost, createTestTestsPost, createTokenTokensPost, createTopicTopicsPost, createTypeLookupTypeLookupsPost, createUseCaseUseCasesPost, createUserUsersPost, deleteBehaviorBehaviorsBehaviorIdDelete, deleteCategoryCategoriesCategoryIdDelete, deleteCommentCommentsCommentIdDelete, deleteDemographicDemographicsDemographicIdDelete, deleteDimensionDimensionsDimensionIdDelete, deleteEndpointEndpointsEndpointIdDelete, deleteMetricMetricsMetricIdDelete, deleteModelModelsModelIdDelete, deleteOrganizationOrganizationsOrganizationIdDelete, deleteProjectProjectsProjectIdDelete, deletePromptPromptsPromptIdDelete, deletePromptTemplatePromptTemplatesPromptTemplateIdDelete, deleteResponsePatternResponsePatternsResponsePatternIdDelete, deleteRiskRisksRiskIdDelete, deleteSourceSourcesSourceIdDelete, deleteStatusStatusesStatusIdDelete, deleteTagTagsTagIdDelete, deleteTaskTasksTaskIdDelete, deleteTestConfigurationTestConfigurationsTestConfigurationIdDelete, deleteTestContextTestContextsTestContextIdDelete, deleteTestResultTestResultsTestResultIdDelete, deleteTestRunTestRunsTestRunIdDelete, deleteTestSetTestSetsTestSetIdDelete, deleteTestTestsTestIdDelete, deleteTokenTokensTokenIdDelete, deleteTopicTopicsTopicIdDelete, deleteTypeLookupTypeLookupsTypeLookupIdDelete, deleteUseCaseUseCasesUseCaseIdDelete, deleteUserUsersUserIdDelete, demoRedirectAuthDemoGet, disassociateTestsFromTestSetTestSetsTestSetIdDisassociatePost, downloadTestRunResultsTestRunsTestRunIdDownloadGet, downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGet, downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGet, emptyRecycleBinForModelRecycleEmptyModelNameDelete, executeTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePost, executeTestSetTestSetsTestSetIdentifierExecuteEndpointIdPost, extractDocumentContentServicesDocumentsExtractPost, generateContentEndpointServicesGenerateContentPost, generateTestConfigServicesGenerateTestConfigPost, generateTestResultStatsTestResultsStatsGet, generateTestRunStatsTestRunsStatsGet, generateTestsEndpointServicesGenerateTestsPost, generateTestSetStatsTestSetsStatsGet, generateTestSetTestSetsGeneratePost, generateTestSetTestStatsTestSetsTestSetIdentifierStatsGet, generateTestStatsTestsStatsGet, generateTextServicesGenerateTextPost, getAiChatResponseServicesOpenaiChatPost, getAiJsonResponseServicesOpenaiJsonPost, getEndpointSchemaEndpointsSchemaGet, getGithubContentsServicesGithubContentsGet, getIndividualTestStatisticsTestsTestIdStatsGet, getRecycleBinCountsRecycleStatsCountsGet, getRecycledRecordsRecycleModelNameGet, getTasksByEntityTasksEntityTypeEntityIdGet, getTaskTasksTaskIdGet, getTestRunBehaviorsTestRunsTestRunIdBehaviorsGet, getTestSetPromptsTestSetsTestSetIdentifierPromptsGet, getTestSetTestsTestSetsTestSetIdentifierTestsGet, homeHomeGet, initializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPost, invokeEndpointEndpointsEndpointIdInvokePost, leaveOrganizationUsersLeaveOrganizationPatch, listAvailableModelsRecycleModelsGet, listTasksTasksGet, loginAuthLoginGet, logoutAuthLogoutGet, type Options, permanentlyDeleteRecordRecycleModelNameItemIdDelete, protectedHomeProtectedGet, readBehaviorBehaviorsBehaviorIdGet, readBehaviorMetricsBehaviorsBehaviorIdMetricsGet, readBehaviorsBehaviorsGet, readCategoriesCategoriesGet, readCategoryCategoriesCategoryIdGet, readCommentCommentsCommentIdGet, readCommentsByEntityCommentsEntityEntityTypeEntityIdGet, readCommentsCommentsGet, readDemographicDemographicsDemographicIdGet, readDemographicsDemographicsGet, readDimensionDimensionsDimensionIdGet, readDimensionsDimensionsGet, readEndpointEndpointsEndpointIdGet, readEndpointsEndpointsGet, readMetricBehaviorsMetricsMetricIdBehaviorsGet, readMetricMetricsMetricIdGet, readMetricsMetricsGet, readModelModelsModelIdGet, readModelsModelsGet, readOrganizationOrganizationsOrganizationIdGet, readOrganizationsOrganizationsGet, readProjectProjectsProjectIdGet, readProjectsProjectsGet, readPromptPromptsPromptIdGet, readPromptsPromptsGet, readPromptTemplatePromptTemplatesPromptTemplateIdGet, readPromptTemplatesPromptTemplatesGet, readResponsePatternResponsePatternsResponsePatternIdGet, readResponsePatternsResponsePatternsGet, readRiskRisksRiskIdGet, readRisksRisksGet, readSourceSourcesSourceIdGet, readSourcesSourcesGet, readStatusesStatusesGet, readStatusStatusesStatusIdGet, readTagsTagsGet, readTagTagsTagIdGet, readTestConfigurationsTestConfigurationsGet, readTestConfigurationTestConfigurationsTestConfigurationIdGet, readTestContextsTestContextsGet, readTestContextTestContextsTestContextIdGet, readTestResultsTestResultsGet, readTestResultTestResultsTestResultIdGet, readTestRunsTestRunsGet, readTestRunTestRunsTestRunIdGet, readTestSetsTestSetsGet, readTestSetTestSetsTestSetIdentifierGet, readTestsTestsGet, readTestTestsTestIdGet, readTokensTokensGet, readTokenTokensTokenIdGet, readTopicsTopicsGet, readTopicTopicsTopicIdGet, readTypeLookupsTypeLookupsGet, readTypeLookupTypeLookupsTypeLookupIdGet, readUseCasesUseCasesGet, readUseCaseUseCasesUseCaseIdGet, readUsersUsersGet, readUserUsersUserIdGet, refreshTokenTokensTokenIdRefreshPost, removeBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDelete, removeEmojiReactionCommentsCommentIdEmojiEmojiDelete, removeMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDelete, removeTagFromEntityTagsEntityTypeEntityIdTagIdDelete, restoreFromRecycleBinRecycleModelNameItemIdRestorePost, rollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPost, rootGet, testModelConnectionModelsModelIdTestPost, updateBehaviorBehaviorsBehaviorIdPut, updateCategoryCategoriesCategoryIdPut, updateCommentCommentsCommentIdPut, updateDemographicDemographicsDemographicIdPut, updateDimensionDimensionsDimensionIdPut, updateEndpointEndpointsEndpointIdPut, updateMetricMetricsMetricIdPut, updateModelModelsModelIdPut, updateOrganizationOrganizationsOrganizationIdPut, updateProjectProjectsProjectIdPut, updatePromptPromptsPromptIdPut, updatePromptTemplatePromptTemplatesPromptTemplateIdPut, updateResponsePatternResponsePatternsResponsePatternIdPut, updateRiskRisksRiskIdPut, updateSourceSourcesSourceIdPut, updateStatusStatusesStatusIdPut, updateTagTagsTagIdPut, updateTaskTasksTaskIdPatch, updateTestConfigurationTestConfigurationsTestConfigurationIdPut, updateTestContextTestContextsTestContextIdPut, updateTestResultTestResultsTestResultIdPut, updateTestRunTestRunsTestRunIdPut, updateTestSetTestSetsTestSetIdPut, updateTestTestsTestIdPut, updateTokenTokensTokenIdPut, updateTopicTopicsTopicIdPut, updateTypeLookupTypeLookupsTypeLookupIdPut, updateUseCaseUseCasesUseCaseIdPut, updateUserUsersUserIdPut, uploadDocumentServicesDocumentsUploadPost, verifyAuthAuthVerifyGet } from '../sdk.gen';
import type { AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostData, AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostError, AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostResponse, AddEmojiReactionCommentsCommentIdEmojiEmojiPostData, AddEmojiReactionCommentsCommentIdEmojiEmojiPostError, AddEmojiReactionCommentsCommentIdEmojiEmojiPostResponse, AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostData, AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostError, AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostResponse, AssignTagToEntityTagsEntityTypeEntityIdPostData, AssignTagToEntityTagsEntityTypeEntityIdPostError, AssignTagToEntityTagsEntityTypeEntityIdPostResponse, AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostData, AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostError, AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostResponse, AuthCallbackAuthCallbackGetData, BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostData, BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostError, BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostResponse, CreateBehaviorBehaviorsPostData, CreateBehaviorBehaviorsPostError, CreateBehaviorBehaviorsPostResponse, CreateCategoryCategoriesPostData, CreateCategoryCategoriesPostError, CreateCategoryCategoriesPostResponse, CreateChatCompletionEndpointServicesChatCompletionsPostData, CreateChatCompletionEndpointServicesChatCompletionsPostError, CreateChatCompletionEndpointServicesChatCompletionsPostResponse, CreateCommentCommentsPostData, CreateCommentCommentsPostError, CreateCommentCommentsPostResponse, CreateDemographicDemographicsPostData, CreateDemographicDemographicsPostError, CreateDemographicDemographicsPostResponse, CreateDimensionDimensionsPostData, CreateDimensionDimensionsPostError, CreateDimensionDimensionsPostResponse, CreateEndpointEndpointsPostData, CreateEndpointEndpointsPostError, CreateEndpointEndpointsPostResponse, CreateMetricMetricsPostData, CreateMetricMetricsPostError, CreateMetricMetricsPostResponse, CreateModelModelsPostData, CreateModelModelsPostError, CreateModelModelsPostResponse, CreateOrganizationOrganizationsPostData, CreateOrganizationOrganizationsPostError, CreateOrganizationOrganizationsPostResponse, CreateProjectProjectsPostData, CreateProjectProjectsPostError, CreateProjectProjectsPostResponse, CreatePromptPromptsPostData, CreatePromptPromptsPostError, CreatePromptPromptsPostResponse, CreatePromptTemplatePromptTemplatesPostData, CreatePromptTemplatePromptTemplatesPostError, CreatePromptTemplatePromptTemplatesPostResponse, CreateResponsePatternResponsePatternsPostData, CreateResponsePatternResponsePatternsPostError, CreateResponsePatternResponsePatternsPostResponse, CreateRiskRisksPostData, CreateRiskRisksPostError, CreateRiskRisksPostResponse, CreateSourceSourcesPostData, CreateSourceSourcesPostError, CreateSourceSourcesPostResponse, CreateStatusStatusesPostData, CreateStatusStatusesPostError, CreateStatusStatusesPostResponse, CreateTagTagsPostData, CreateTagTagsPostError, CreateTagTagsPostResponse, CreateTaskTasksPostData, CreateTaskTasksPostError, CreateTaskTasksPostResponse, CreateTestConfigurationTestConfigurationsPostData, CreateTestConfigurationTestConfigurationsPostError, CreateTestConfigurationTestConfigurationsPostResponse, CreateTestContextTestContextsPostData, CreateTestContextTestContextsPostError, CreateTestContextTestContextsPostResponse, CreateTestResultTestResultsPostData, CreateTestResultTestResultsPostError, CreateTestResultTestResultsPostResponse, CreateTestRunTestRunsPostData, CreateTestRunTestRunsPostError, CreateTestRunTestRunsPostResponse, CreateTestsBulkTestsBulkPostData, CreateTestsBulkTestsBulkPostError, CreateTestsBulkTestsBulkPostResponse, CreateTestSetBulkTestSetsBulkPostData, CreateTestSetBulkTestSetsBulkPostError, CreateTestSetBulkTestSetsBulkPostResponse, CreateTestSetTestSetsPostData, CreateTestSetTestSetsPostError, CreateTestSetTestSetsPostResponse, CreateTestTestsPostData, CreateTestTestsPostError, CreateTestTestsPostResponse, CreateTokenTokensPostData, CreateTokenTokensPostError, CreateTokenTokensPostResponse, CreateTopicTopicsPostData, CreateTopicTopicsPostError, CreateTopicTopicsPostResponse, CreateTypeLookupTypeLookupsPostData, CreateTypeLookupTypeLookupsPostError, CreateTypeLookupTypeLookupsPostResponse, CreateUseCaseUseCasesPostData, CreateUseCaseUseCasesPostError, CreateUseCaseUseCasesPostResponse, CreateUserUsersPostData, CreateUserUsersPostError, CreateUserUsersPostResponse, DeleteBehaviorBehaviorsBehaviorIdDeleteData, DeleteBehaviorBehaviorsBehaviorIdDeleteError, DeleteBehaviorBehaviorsBehaviorIdDeleteResponse, DeleteCategoryCategoriesCategoryIdDeleteData, DeleteCategoryCategoriesCategoryIdDeleteError, DeleteCategoryCategoriesCategoryIdDeleteResponse, DeleteCommentCommentsCommentIdDeleteData, DeleteCommentCommentsCommentIdDeleteError, DeleteCommentCommentsCommentIdDeleteResponse, DeleteDemographicDemographicsDemographicIdDeleteData, DeleteDemographicDemographicsDemographicIdDeleteError, DeleteDemographicDemographicsDemographicIdDeleteResponse, DeleteDimensionDimensionsDimensionIdDeleteData, DeleteDimensionDimensionsDimensionIdDeleteError, DeleteDimensionDimensionsDimensionIdDeleteResponse, DeleteEndpointEndpointsEndpointIdDeleteData, DeleteEndpointEndpointsEndpointIdDeleteError, DeleteEndpointEndpointsEndpointIdDeleteResponse, DeleteMetricMetricsMetricIdDeleteData, DeleteMetricMetricsMetricIdDeleteError, DeleteMetricMetricsMetricIdDeleteResponse, DeleteModelModelsModelIdDeleteData, DeleteModelModelsModelIdDeleteError, DeleteModelModelsModelIdDeleteResponse, DeleteOrganizationOrganizationsOrganizationIdDeleteData, DeleteOrganizationOrganizationsOrganizationIdDeleteError, DeleteOrganizationOrganizationsOrganizationIdDeleteResponse, DeleteProjectProjectsProjectIdDeleteData, DeleteProjectProjectsProjectIdDeleteError, DeleteProjectProjectsProjectIdDeleteResponse, DeletePromptPromptsPromptIdDeleteData, DeletePromptPromptsPromptIdDeleteError, DeletePromptPromptsPromptIdDeleteResponse, DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteData, DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteError, DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteResponse, DeleteResponsePatternResponsePatternsResponsePatternIdDeleteData, DeleteResponsePatternResponsePatternsResponsePatternIdDeleteError, DeleteResponsePatternResponsePatternsResponsePatternIdDeleteResponse, DeleteRiskRisksRiskIdDeleteData, DeleteRiskRisksRiskIdDeleteError, DeleteRiskRisksRiskIdDeleteResponse, DeleteSourceSourcesSourceIdDeleteData, DeleteSourceSourcesSourceIdDeleteError, DeleteSourceSourcesSourceIdDeleteResponse, DeleteStatusStatusesStatusIdDeleteData, DeleteStatusStatusesStatusIdDeleteError, DeleteStatusStatusesStatusIdDeleteResponse, DeleteTagTagsTagIdDeleteData, DeleteTagTagsTagIdDeleteError, DeleteTagTagsTagIdDeleteResponse, DeleteTaskTasksTaskIdDeleteData, DeleteTaskTasksTaskIdDeleteError, DeleteTaskTasksTaskIdDeleteResponse, DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteData, DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteError, DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteResponse, DeleteTestContextTestContextsTestContextIdDeleteData, DeleteTestContextTestContextsTestContextIdDeleteError, DeleteTestContextTestContextsTestContextIdDeleteResponse, DeleteTestResultTestResultsTestResultIdDeleteData, DeleteTestResultTestResultsTestResultIdDeleteError, DeleteTestResultTestResultsTestResultIdDeleteResponse, DeleteTestRunTestRunsTestRunIdDeleteData, DeleteTestRunTestRunsTestRunIdDeleteError, DeleteTestRunTestRunsTestRunIdDeleteResponse, DeleteTestSetTestSetsTestSetIdDeleteData, DeleteTestSetTestSetsTestSetIdDeleteError, DeleteTestSetTestSetsTestSetIdDeleteResponse, DeleteTestTestsTestIdDeleteData, DeleteTestTestsTestIdDeleteError, DeleteTestTestsTestIdDeleteResponse, DeleteTokenTokensTokenIdDeleteData, DeleteTokenTokensTokenIdDeleteError, DeleteTokenTokensTokenIdDeleteResponse, DeleteTopicTopicsTopicIdDeleteData, DeleteTopicTopicsTopicIdDeleteError, DeleteTopicTopicsTopicIdDeleteResponse, DeleteTypeLookupTypeLookupsTypeLookupIdDeleteData, DeleteTypeLookupTypeLookupsTypeLookupIdDeleteError, DeleteTypeLookupTypeLookupsTypeLookupIdDeleteResponse, DeleteUseCaseUseCasesUseCaseIdDeleteData, DeleteUseCaseUseCasesUseCaseIdDeleteError, DeleteUseCaseUseCasesUseCaseIdDeleteResponse, DeleteUserUsersUserIdDeleteData, DeleteUserUsersUserIdDeleteError, DeleteUserUsersUserIdDeleteResponse, DemoRedirectAuthDemoGetData, DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostData, DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostError, DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostResponse, DownloadTestRunResultsTestRunsTestRunIdDownloadGetData, DownloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetData, DownloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetData, EmptyRecycleBinForModelRecycleEmptyModelNameDeleteData, EmptyRecycleBinForModelRecycleEmptyModelNameDeleteError, EmptyRecycleBinForModelRecycleEmptyModelNameDeleteResponse, ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostData, ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostError, ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostResponse, ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostData, ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostError, ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostResponse, ExtractDocumentContentServicesDocumentsExtractPostData, ExtractDocumentContentServicesDocumentsExtractPostError, ExtractDocumentContentServicesDocumentsExtractPostResponse, GenerateContentEndpointServicesGenerateContentPostData, GenerateContentEndpointServicesGenerateContentPostError, GenerateContentEndpointServicesGenerateContentPostResponse, GenerateTestConfigServicesGenerateTestConfigPostData, GenerateTestConfigServicesGenerateTestConfigPostError, GenerateTestConfigServicesGenerateTestConfigPostResponse, GenerateTestResultStatsTestResultsStatsGetData, GenerateTestRunStatsTestRunsStatsGetData, GenerateTestsEndpointServicesGenerateTestsPostData, GenerateTestsEndpointServicesGenerateTestsPostError, GenerateTestsEndpointServicesGenerateTestsPostResponse, GenerateTestSetStatsTestSetsStatsGetData, GenerateTestSetTestSetsGeneratePostData, GenerateTestSetTestSetsGeneratePostError, GenerateTestSetTestSetsGeneratePostResponse, GenerateTestSetTestStatsTestSetsTestSetIdentifierStatsGetData, GenerateTestStatsTestsStatsGetData, GenerateTextServicesGenerateTextPostData, GenerateTextServicesGenerateTextPostError, GenerateTextServicesGenerateTextPostResponse, GetAiChatResponseServicesOpenaiChatPostData, GetAiChatResponseServicesOpenaiChatPostError, GetAiChatResponseServicesOpenaiChatPostResponse, GetAiJsonResponseServicesOpenaiJsonPostData, GetAiJsonResponseServicesOpenaiJsonPostError, GetAiJsonResponseServicesOpenaiJsonPostResponse, GetEndpointSchemaEndpointsSchemaGetData, GetGithubContentsServicesGithubContentsGetData, GetIndividualTestStatisticsTestsTestIdStatsGetData, GetRecycleBinCountsRecycleStatsCountsGetData, GetRecycledRecordsRecycleModelNameGetData, GetTasksByEntityTasksEntityTypeEntityIdGetData, GetTaskTasksTaskIdGetData, GetTestRunBehaviorsTestRunsTestRunIdBehaviorsGetData, GetTestSetPromptsTestSetsTestSetIdentifierPromptsGetData, GetTestSetTestsTestSetsTestSetIdentifierTestsGetData, HomeHomeGetData, InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostData, InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostError, InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostResponse, InvokeEndpointEndpointsEndpointIdInvokePostData, InvokeEndpointEndpointsEndpointIdInvokePostError, InvokeEndpointEndpointsEndpointIdInvokePostResponse, LeaveOrganizationUsersLeaveOrganizationPatchData, LeaveOrganizationUsersLeaveOrganizationPatchResponse, ListAvailableModelsRecycleModelsGetData, ListTasksTasksGetData, LoginAuthLoginGetData, LogoutAuthLogoutGetData, PermanentlyDeleteRecordRecycleModelNameItemIdDeleteData, PermanentlyDeleteRecordRecycleModelNameItemIdDeleteError, PermanentlyDeleteRecordRecycleModelNameItemIdDeleteResponse, ProtectedHomeProtectedGetData, ReadBehaviorBehaviorsBehaviorIdGetData, ReadBehaviorMetricsBehaviorsBehaviorIdMetricsGetData, ReadBehaviorsBehaviorsGetData, ReadCategoriesCategoriesGetData, ReadCategoryCategoriesCategoryIdGetData, ReadCommentCommentsCommentIdGetData, ReadCommentsByEntityCommentsEntityEntityTypeEntityIdGetData, ReadCommentsCommentsGetData, ReadDemographicDemographicsDemographicIdGetData, ReadDemographicsDemographicsGetData, ReadDimensionDimensionsDimensionIdGetData, ReadDimensionsDimensionsGetData, ReadEndpointEndpointsEndpointIdGetData, ReadEndpointsEndpointsGetData, ReadMetricBehaviorsMetricsMetricIdBehaviorsGetData, ReadMetricMetricsMetricIdGetData, ReadMetricsMetricsGetData, ReadModelModelsModelIdGetData, ReadModelsModelsGetData, ReadOrganizationOrganizationsOrganizationIdGetData, ReadOrganizationsOrganizationsGetData, ReadProjectProjectsProjectIdGetData, ReadProjectsProjectsGetData, ReadPromptPromptsPromptIdGetData, ReadPromptsPromptsGetData, ReadPromptTemplatePromptTemplatesPromptTemplateIdGetData, ReadPromptTemplatesPromptTemplatesGetData, ReadResponsePatternResponsePatternsResponsePatternIdGetData, ReadResponsePatternsResponsePatternsGetData, ReadRiskRisksRiskIdGetData, ReadRisksRisksGetData, ReadSourceSourcesSourceIdGetData, ReadSourcesSourcesGetData, ReadStatusesStatusesGetData, ReadStatusStatusesStatusIdGetData, ReadTagsTagsGetData, ReadTagTagsTagIdGetData, ReadTestConfigurationsTestConfigurationsGetData, ReadTestConfigurationTestConfigurationsTestConfigurationIdGetData, ReadTestContextsTestContextsGetData, ReadTestContextTestContextsTestContextIdGetData, ReadTestResultsTestResultsGetData, ReadTestResultTestResultsTestResultIdGetData, ReadTestRunsTestRunsGetData, ReadTestRunTestRunsTestRunIdGetData, ReadTestSetsTestSetsGetData, ReadTestSetTestSetsTestSetIdentifierGetData, ReadTestsTestsGetData, ReadTestTestsTestIdGetData, ReadTokensTokensGetData, ReadTokenTokensTokenIdGetData, ReadTopicsTopicsGetData, ReadTopicTopicsTopicIdGetData, ReadTypeLookupsTypeLookupsGetData, ReadTypeLookupTypeLookupsTypeLookupIdGetData, ReadUseCasesUseCasesGetData, ReadUseCaseUseCasesUseCaseIdGetData, ReadUsersUsersGetData, ReadUserUsersUserIdGetData, RefreshTokenTokensTokenIdRefreshPostData, RefreshTokenTokensTokenIdRefreshPostError, RefreshTokenTokensTokenIdRefreshPostResponse, RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteData, RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteError, RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteResponse, RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteData, RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteError, RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteResponse, RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteData, RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteError, RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteResponse, RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteData, RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteError, RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteResponse, RestoreFromRecycleBinRecycleModelNameItemIdRestorePostData, RestoreFromRecycleBinRecycleModelNameItemIdRestorePostError, RestoreFromRecycleBinRecycleModelNameItemIdRestorePostResponse, RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostData, RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostError, RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostResponse, RootGetData, TestModelConnectionModelsModelIdTestPostData, TestModelConnectionModelsModelIdTestPostError, TestModelConnectionModelsModelIdTestPostResponse, UpdateBehaviorBehaviorsBehaviorIdPutData, UpdateBehaviorBehaviorsBehaviorIdPutError, UpdateBehaviorBehaviorsBehaviorIdPutResponse, UpdateCategoryCategoriesCategoryIdPutData, UpdateCategoryCategoriesCategoryIdPutError, UpdateCategoryCategoriesCategoryIdPutResponse, UpdateCommentCommentsCommentIdPutData, UpdateCommentCommentsCommentIdPutError, UpdateCommentCommentsCommentIdPutResponse, UpdateDemographicDemographicsDemographicIdPutData, UpdateDemographicDemographicsDemographicIdPutError, UpdateDemographicDemographicsDemographicIdPutResponse, UpdateDimensionDimensionsDimensionIdPutData, UpdateDimensionDimensionsDimensionIdPutError, UpdateDimensionDimensionsDimensionIdPutResponse, UpdateEndpointEndpointsEndpointIdPutData, UpdateEndpointEndpointsEndpointIdPutError, UpdateEndpointEndpointsEndpointIdPutResponse, UpdateMetricMetricsMetricIdPutData, UpdateMetricMetricsMetricIdPutError, UpdateMetricMetricsMetricIdPutResponse, UpdateModelModelsModelIdPutData, UpdateModelModelsModelIdPutError, UpdateModelModelsModelIdPutResponse, UpdateOrganizationOrganizationsOrganizationIdPutData, UpdateOrganizationOrganizationsOrganizationIdPutError, UpdateOrganizationOrganizationsOrganizationIdPutResponse, UpdateProjectProjectsProjectIdPutData, UpdateProjectProjectsProjectIdPutError, UpdateProjectProjectsProjectIdPutResponse, UpdatePromptPromptsPromptIdPutData, UpdatePromptPromptsPromptIdPutError, UpdatePromptPromptsPromptIdPutResponse, UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutData, UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutError, UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutResponse, UpdateResponsePatternResponsePatternsResponsePatternIdPutData, UpdateResponsePatternResponsePatternsResponsePatternIdPutError, UpdateResponsePatternResponsePatternsResponsePatternIdPutResponse, UpdateRiskRisksRiskIdPutData, UpdateRiskRisksRiskIdPutError, UpdateRiskRisksRiskIdPutResponse, UpdateSourceSourcesSourceIdPutData, UpdateSourceSourcesSourceIdPutError, UpdateSourceSourcesSourceIdPutResponse, UpdateStatusStatusesStatusIdPutData, UpdateStatusStatusesStatusIdPutError, UpdateStatusStatusesStatusIdPutResponse, UpdateTagTagsTagIdPutData, UpdateTagTagsTagIdPutError, UpdateTagTagsTagIdPutResponse, UpdateTaskTasksTaskIdPatchData, UpdateTaskTasksTaskIdPatchError, UpdateTaskTasksTaskIdPatchResponse, UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutData, UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutError, UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutResponse, UpdateTestContextTestContextsTestContextIdPutData, UpdateTestContextTestContextsTestContextIdPutError, UpdateTestContextTestContextsTestContextIdPutResponse, UpdateTestResultTestResultsTestResultIdPutData, UpdateTestResultTestResultsTestResultIdPutError, UpdateTestResultTestResultsTestResultIdPutResponse, UpdateTestRunTestRunsTestRunIdPutData, UpdateTestRunTestRunsTestRunIdPutError, UpdateTestRunTestRunsTestRunIdPutResponse, UpdateTestSetTestSetsTestSetIdPutData, UpdateTestSetTestSetsTestSetIdPutError, UpdateTestSetTestSetsTestSetIdPutResponse, UpdateTestTestsTestIdPutData, UpdateTestTestsTestIdPutError, UpdateTestTestsTestIdPutResponse, UpdateTokenTokensTokenIdPutData, UpdateTokenTokensTokenIdPutError, UpdateTokenTokensTokenIdPutResponse, UpdateTopicTopicsTopicIdPutData, UpdateTopicTopicsTopicIdPutError, UpdateTopicTopicsTopicIdPutResponse, UpdateTypeLookupTypeLookupsTypeLookupIdPutData, UpdateTypeLookupTypeLookupsTypeLookupIdPutError, UpdateTypeLookupTypeLookupsTypeLookupIdPutResponse, UpdateUseCaseUseCasesUseCaseIdPutData, UpdateUseCaseUseCasesUseCaseIdPutError, UpdateUseCaseUseCasesUseCaseIdPutResponse, UpdateUserUsersUserIdPutData, UpdateUserUsersUserIdPutError, UpdateUserUsersUserIdPutResponse, UploadDocumentServicesDocumentsUploadPostData, UploadDocumentServicesDocumentsUploadPostError, UploadDocumentServicesDocumentsUploadPostResponse, VerifyAuthAuthVerifyGetData } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const loginAuthLoginGetQueryKey = (options?: Options<LoginAuthLoginGetData>) => createQueryKey('loginAuthLoginGet', options, false, [
    'authentication'
]);

/**
 * Login
 * Redirect users to Auth0 login page
 */
export const loginAuthLoginGetOptions = (options?: Options<LoginAuthLoginGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginAuthLoginGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginAuthLoginGetQueryKey(options)
    });
};

export const authCallbackAuthCallbackGetQueryKey = (options?: Options<AuthCallbackAuthCallbackGetData>) => createQueryKey('authCallbackAuthCallbackGet', options, false, [
    'authentication'
]);

/**
 * Auth Callback
 * Handle the Auth0 callback after successful authentication
 */
export const authCallbackAuthCallbackGetOptions = (options?: Options<AuthCallbackAuthCallbackGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authCallbackAuthCallbackGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authCallbackAuthCallbackGetQueryKey(options)
    });
};

export const logoutAuthLogoutGetQueryKey = (options?: Options<LogoutAuthLogoutGetData>) => createQueryKey('logoutAuthLogoutGet', options, false, [
    'authentication'
]);

/**
 * Logout
 * Log out the user and clear their session
 */
export const logoutAuthLogoutGetOptions = (options?: Options<LogoutAuthLogoutGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logoutAuthLogoutGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutAuthLogoutGetQueryKey(options)
    });
};

export const verifyAuthAuthVerifyGetQueryKey = (options: Options<VerifyAuthAuthVerifyGetData>) => createQueryKey('verifyAuthAuthVerifyGet', options, false, [
    'authentication'
]);

/**
 * Verify Auth
 * Verify JWT session token and return user info
 */
export const verifyAuthAuthVerifyGetOptions = (options: Options<VerifyAuthAuthVerifyGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyAuthAuthVerifyGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyAuthAuthVerifyGetQueryKey(options)
    });
};

export const demoRedirectAuthDemoGetQueryKey = (options?: Options<DemoRedirectAuthDemoGetData>) => createQueryKey('demoRedirectAuthDemoGet', options, false, [
    'authentication'
]);

/**
 * Demo Redirect
 * Redirect to Auth0 login with demo user pre-filled
 */
export const demoRedirectAuthDemoGetOptions = (options?: Options<DemoRedirectAuthDemoGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await demoRedirectAuthDemoGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: demoRedirectAuthDemoGetQueryKey(options)
    });
};

export const readBehaviorsBehaviorsGetQueryKey = (options?: Options<ReadBehaviorsBehaviorsGetData>) => createQueryKey('readBehaviorsBehaviorsGet', options, false, [
    'behaviors'
]);

/**
 * Read Behaviors
 * Get all behaviors with automatic session variables for RLS.
 */
export const readBehaviorsBehaviorsGetOptions = (options?: Options<ReadBehaviorsBehaviorsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readBehaviorsBehaviorsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readBehaviorsBehaviorsGetQueryKey(options)
    });
};

/**
 * Create Behavior
 * Create behavior with automatic session variables for RLS.
 */
export const createBehaviorBehaviorsPostMutation = (options?: Partial<Options<CreateBehaviorBehaviorsPostData>>): UseMutationOptions<CreateBehaviorBehaviorsPostResponse, CreateBehaviorBehaviorsPostError, Options<CreateBehaviorBehaviorsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateBehaviorBehaviorsPostResponse, CreateBehaviorBehaviorsPostError, Options<CreateBehaviorBehaviorsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBehaviorBehaviorsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Behavior
 * Delete behavior with automatic session variables for RLS.
 */
export const deleteBehaviorBehaviorsBehaviorIdDeleteMutation = (options?: Partial<Options<DeleteBehaviorBehaviorsBehaviorIdDeleteData>>): UseMutationOptions<DeleteBehaviorBehaviorsBehaviorIdDeleteResponse, DeleteBehaviorBehaviorsBehaviorIdDeleteError, Options<DeleteBehaviorBehaviorsBehaviorIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteBehaviorBehaviorsBehaviorIdDeleteResponse, DeleteBehaviorBehaviorsBehaviorIdDeleteError, Options<DeleteBehaviorBehaviorsBehaviorIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBehaviorBehaviorsBehaviorIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readBehaviorBehaviorsBehaviorIdGetQueryKey = (options: Options<ReadBehaviorBehaviorsBehaviorIdGetData>) => createQueryKey('readBehaviorBehaviorsBehaviorIdGet', options, false, [
    'behaviors'
]);

/**
 * Read Behavior
 * Get behavior by ID with automatic session variables for RLS.
 */
export const readBehaviorBehaviorsBehaviorIdGetOptions = (options: Options<ReadBehaviorBehaviorsBehaviorIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readBehaviorBehaviorsBehaviorIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readBehaviorBehaviorsBehaviorIdGetQueryKey(options)
    });
};

/**
 * Update Behavior
 * Update behavior with automatic session variables for RLS.
 */
export const updateBehaviorBehaviorsBehaviorIdPutMutation = (options?: Partial<Options<UpdateBehaviorBehaviorsBehaviorIdPutData>>): UseMutationOptions<UpdateBehaviorBehaviorsBehaviorIdPutResponse, UpdateBehaviorBehaviorsBehaviorIdPutError, Options<UpdateBehaviorBehaviorsBehaviorIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateBehaviorBehaviorsBehaviorIdPutResponse, UpdateBehaviorBehaviorsBehaviorIdPutError, Options<UpdateBehaviorBehaviorsBehaviorIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBehaviorBehaviorsBehaviorIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readBehaviorMetricsBehaviorsBehaviorIdMetricsGetQueryKey = (options: Options<ReadBehaviorMetricsBehaviorsBehaviorIdMetricsGetData>) => createQueryKey('readBehaviorMetricsBehaviorsBehaviorIdMetricsGet', options, false, [
    'behaviors'
]);

/**
 * Read Behavior Metrics
 * Get all metrics associated with a behavior
 */
export const readBehaviorMetricsBehaviorsBehaviorIdMetricsGetOptions = (options: Options<ReadBehaviorMetricsBehaviorsBehaviorIdMetricsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readBehaviorMetricsBehaviorsBehaviorIdMetricsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readBehaviorMetricsBehaviorsBehaviorIdMetricsGetQueryKey(options)
    });
};

/**
 * Remove Metric From Behavior
 * Remove a metric from a behavior
 */
export const removeMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteMutation = (options?: Partial<Options<RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteData>>): UseMutationOptions<RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteResponse, RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteError, Options<RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteResponse, RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteError, Options<RemoveMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeMetricFromBehaviorBehaviorsBehaviorIdMetricsMetricIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add Metric To Behavior
 * Add a metric to a behavior
 */
export const addMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostMutation = (options?: Partial<Options<AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostData>>): UseMutationOptions<AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostResponse, AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostError, Options<AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostData>> => {
    const mutationOptions: UseMutationOptions<AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostResponse, AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostError, Options<AddMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addMetricToBehaviorBehaviorsBehaviorIdMetricsMetricIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readCategoriesCategoriesGetQueryKey = (options?: Options<ReadCategoriesCategoriesGetData>) => createQueryKey('readCategoriesCategoriesGet', options, false, [
    'categories'
]);

/**
 * Read Categories
 * Get all categories with their related objects
 */
export const readCategoriesCategoriesGetOptions = (options?: Options<ReadCategoriesCategoriesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readCategoriesCategoriesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readCategoriesCategoriesGetQueryKey(options)
    });
};

/**
 * Create Category
 * Create category with optimized approach supporting both RLS and explicit parameters.
 *
 * Performance improvements:
 * - Automatically sets PostgreSQL session variables for RLS policies
 * - Maintains explicit parameter passing for maximum compatibility
 * - Single database connection with optimized session variable caching
 * - Drop-in replacement requiring minimal code changes
 */
export const createCategoryCategoriesPostMutation = (options?: Partial<Options<CreateCategoryCategoriesPostData>>): UseMutationOptions<CreateCategoryCategoriesPostResponse, CreateCategoryCategoriesPostError, Options<CreateCategoryCategoriesPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryCategoriesPostResponse, CreateCategoryCategoriesPostError, Options<CreateCategoryCategoriesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategoryCategoriesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Category
 * Delete category with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteCategoryCategoriesCategoryIdDeleteMutation = (options?: Partial<Options<DeleteCategoryCategoriesCategoryIdDeleteData>>): UseMutationOptions<DeleteCategoryCategoriesCategoryIdDeleteResponse, DeleteCategoryCategoriesCategoryIdDeleteError, Options<DeleteCategoryCategoriesCategoryIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryCategoriesCategoryIdDeleteResponse, DeleteCategoryCategoriesCategoryIdDeleteError, Options<DeleteCategoryCategoriesCategoryIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCategoryCategoriesCategoryIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readCategoryCategoriesCategoryIdGetQueryKey = (options: Options<ReadCategoryCategoriesCategoryIdGetData>) => createQueryKey('readCategoryCategoriesCategoryIdGet', options, false, [
    'categories'
]);

/**
 * Read Category
 * Get category with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readCategoryCategoriesCategoryIdGetOptions = (options: Options<ReadCategoryCategoriesCategoryIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readCategoryCategoriesCategoryIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readCategoryCategoriesCategoryIdGetQueryKey(options)
    });
};

/**
 * Update Category
 * Update category with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateCategoryCategoriesCategoryIdPutMutation = (options?: Partial<Options<UpdateCategoryCategoriesCategoryIdPutData>>): UseMutationOptions<UpdateCategoryCategoriesCategoryIdPutResponse, UpdateCategoryCategoriesCategoryIdPutError, Options<UpdateCategoryCategoriesCategoryIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateCategoryCategoriesCategoryIdPutResponse, UpdateCategoryCategoriesCategoryIdPutError, Options<UpdateCategoryCategoriesCategoryIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCategoryCategoriesCategoryIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readCommentsCommentsGetQueryKey = (options?: Options<ReadCommentsCommentsGetData>) => createQueryKey('readCommentsCommentsGet', options, false, [
    'comments'
]);

/**
 * Read Comments
 * Get all comments with filtering and pagination - optimized approach.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - Direct tenant context injection
 */
export const readCommentsCommentsGetOptions = (options?: Options<ReadCommentsCommentsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readCommentsCommentsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readCommentsCommentsGetQueryKey(options)
    });
};

/**
 * Create Comment
 * Create comment with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createCommentCommentsPostMutation = (options?: Partial<Options<CreateCommentCommentsPostData>>): UseMutationOptions<CreateCommentCommentsPostResponse, CreateCommentCommentsPostError, Options<CreateCommentCommentsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCommentCommentsPostResponse, CreateCommentCommentsPostError, Options<CreateCommentCommentsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCommentCommentsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Comment
 * Delete comment with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteCommentCommentsCommentIdDeleteMutation = (options?: Partial<Options<DeleteCommentCommentsCommentIdDeleteData>>): UseMutationOptions<DeleteCommentCommentsCommentIdDeleteResponse, DeleteCommentCommentsCommentIdDeleteError, Options<DeleteCommentCommentsCommentIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCommentCommentsCommentIdDeleteResponse, DeleteCommentCommentsCommentIdDeleteError, Options<DeleteCommentCommentsCommentIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCommentCommentsCommentIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readCommentCommentsCommentIdGetQueryKey = (options: Options<ReadCommentCommentsCommentIdGetData>) => createQueryKey('readCommentCommentsCommentIdGet', options, false, [
    'comments'
]);

/**
 * Read Comment
 * Get comment with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readCommentCommentsCommentIdGetOptions = (options: Options<ReadCommentCommentsCommentIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readCommentCommentsCommentIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readCommentCommentsCommentIdGetQueryKey(options)
    });
};

/**
 * Update Comment
 * Update comment with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateCommentCommentsCommentIdPutMutation = (options?: Partial<Options<UpdateCommentCommentsCommentIdPutData>>): UseMutationOptions<UpdateCommentCommentsCommentIdPutResponse, UpdateCommentCommentsCommentIdPutError, Options<UpdateCommentCommentsCommentIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateCommentCommentsCommentIdPutResponse, UpdateCommentCommentsCommentIdPutError, Options<UpdateCommentCommentsCommentIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCommentCommentsCommentIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readCommentsByEntityCommentsEntityEntityTypeEntityIdGetQueryKey = (options: Options<ReadCommentsByEntityCommentsEntityEntityTypeEntityIdGetData>) => createQueryKey('readCommentsByEntityCommentsEntityEntityTypeEntityIdGet', options, false, [
    'comments'
]);

/**
 * Read Comments By Entity
 * Get all comments for a specific entity - optimized approach.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - Direct tenant context injection
 *
 * Supported entities: Test, TestSet, TestRun, TestResult, PromptTemplate,
 * Metric, Model, Prompt, Behavior, Category, Source
 */
export const readCommentsByEntityCommentsEntityEntityTypeEntityIdGetOptions = (options: Options<ReadCommentsByEntityCommentsEntityEntityTypeEntityIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readCommentsByEntityCommentsEntityEntityTypeEntityIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readCommentsByEntityCommentsEntityEntityTypeEntityIdGetQueryKey(options)
    });
};

/**
 * Remove Emoji Reaction
 * Remove an emoji reaction from a comment - optimized approach.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - Direct tenant context injection
 */
export const removeEmojiReactionCommentsCommentIdEmojiEmojiDeleteMutation = (options?: Partial<Options<RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteData>>): UseMutationOptions<RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteResponse, RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteError, Options<RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteData>> => {
    const mutationOptions: UseMutationOptions<RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteResponse, RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteError, Options<RemoveEmojiReactionCommentsCommentIdEmojiEmojiDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeEmojiReactionCommentsCommentIdEmojiEmojiDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add Emoji Reaction
 * ## Emoji Reactions Structure
 *
 * Emoji reactions are stored as JSON in the `emojis` field of each comment.
 * The structure is: {emoji_character: [list_of_user_reactions]}
 *
 * ### Example Comment Response:
 * ```json
 * {
 * "id": "uuid",
 * "content": "Great work on this test!",
 * "emojis": {
 * "🚀": [
 * {"user_id": "user-uuid-1", "user_name": "John Doe"},
 * {"user_id": "user-uuid-2", "user_name": "Jane Smith"}
 * ],
 * "👍": [
 * {"user_id": "user-uuid-3", "user_name": "Bob Wilson"}
 * ]
 * },
 * "entity_id": "test-uuid",
 * "entity_type": "Test",
 * "user_id": "author-uuid",
 * "organization_id": "org-uuid",
 * "created_at": "2024-01-01T12:00:00Z",
 * "updated_at": "2024-01-01T12:00:00Z"
 * }
 * ```
 *
 * ### Key Points:
 * - **Emoji Character**: The emoji itself (🚀, 👍, ❤️) is the dictionary key
 * - **User Reactions**: Each emoji maps to a list of users who reacted
 * - **User Data**: Each reaction includes `user_id` and `user_name`
 * - **No Duplicates**: A user can only react once per emoji per comment
 */
export const addEmojiReactionCommentsCommentIdEmojiEmojiPostMutation = (options?: Partial<Options<AddEmojiReactionCommentsCommentIdEmojiEmojiPostData>>): UseMutationOptions<AddEmojiReactionCommentsCommentIdEmojiEmojiPostResponse, AddEmojiReactionCommentsCommentIdEmojiEmojiPostError, Options<AddEmojiReactionCommentsCommentIdEmojiEmojiPostData>> => {
    const mutationOptions: UseMutationOptions<AddEmojiReactionCommentsCommentIdEmojiEmojiPostResponse, AddEmojiReactionCommentsCommentIdEmojiEmojiPostError, Options<AddEmojiReactionCommentsCommentIdEmojiEmojiPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addEmojiReactionCommentsCommentIdEmojiEmojiPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readDemographicsDemographicsGetQueryKey = (options?: Options<ReadDemographicsDemographicsGetData>) => createQueryKey('readDemographicsDemographicsGet', options, false, [
    'demographics'
]);

/**
 * Read Demographics
 * Get all demographics with their related objects
 */
export const readDemographicsDemographicsGetOptions = (options?: Options<ReadDemographicsDemographicsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readDemographicsDemographicsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readDemographicsDemographicsGetQueryKey(options)
    });
};

/**
 * Create Demographic
 * Create demographic with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createDemographicDemographicsPostMutation = (options?: Partial<Options<CreateDemographicDemographicsPostData>>): UseMutationOptions<CreateDemographicDemographicsPostResponse, CreateDemographicDemographicsPostError, Options<CreateDemographicDemographicsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateDemographicDemographicsPostResponse, CreateDemographicDemographicsPostError, Options<CreateDemographicDemographicsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDemographicDemographicsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Demographic
 */
export const deleteDemographicDemographicsDemographicIdDeleteMutation = (options?: Partial<Options<DeleteDemographicDemographicsDemographicIdDeleteData>>): UseMutationOptions<DeleteDemographicDemographicsDemographicIdDeleteResponse, DeleteDemographicDemographicsDemographicIdDeleteError, Options<DeleteDemographicDemographicsDemographicIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteDemographicDemographicsDemographicIdDeleteResponse, DeleteDemographicDemographicsDemographicIdDeleteError, Options<DeleteDemographicDemographicsDemographicIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDemographicDemographicsDemographicIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readDemographicDemographicsDemographicIdGetQueryKey = (options: Options<ReadDemographicDemographicsDemographicIdGetData>) => createQueryKey('readDemographicDemographicsDemographicIdGet', options, false, [
    'demographics'
]);

/**
 * Read Demographic
 */
export const readDemographicDemographicsDemographicIdGetOptions = (options: Options<ReadDemographicDemographicsDemographicIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readDemographicDemographicsDemographicIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readDemographicDemographicsDemographicIdGetQueryKey(options)
    });
};

/**
 * Update Demographic
 * Update demographic with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateDemographicDemographicsDemographicIdPutMutation = (options?: Partial<Options<UpdateDemographicDemographicsDemographicIdPutData>>): UseMutationOptions<UpdateDemographicDemographicsDemographicIdPutResponse, UpdateDemographicDemographicsDemographicIdPutError, Options<UpdateDemographicDemographicsDemographicIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateDemographicDemographicsDemographicIdPutResponse, UpdateDemographicDemographicsDemographicIdPutError, Options<UpdateDemographicDemographicsDemographicIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDemographicDemographicsDemographicIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readDimensionsDimensionsGetQueryKey = (options?: Options<ReadDimensionsDimensionsGetData>) => createQueryKey('readDimensionsDimensionsGet', options, false, [
    'dimensions'
]);

/**
 * Read Dimensions
 * Get all dimensions with their related objects
 */
export const readDimensionsDimensionsGetOptions = (options?: Options<ReadDimensionsDimensionsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readDimensionsDimensionsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readDimensionsDimensionsGetQueryKey(options)
    });
};

/**
 * Create Dimension
 * Create dimension with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createDimensionDimensionsPostMutation = (options?: Partial<Options<CreateDimensionDimensionsPostData>>): UseMutationOptions<CreateDimensionDimensionsPostResponse, CreateDimensionDimensionsPostError, Options<CreateDimensionDimensionsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateDimensionDimensionsPostResponse, CreateDimensionDimensionsPostError, Options<CreateDimensionDimensionsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDimensionDimensionsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Dimension
 */
export const deleteDimensionDimensionsDimensionIdDeleteMutation = (options?: Partial<Options<DeleteDimensionDimensionsDimensionIdDeleteData>>): UseMutationOptions<DeleteDimensionDimensionsDimensionIdDeleteResponse, DeleteDimensionDimensionsDimensionIdDeleteError, Options<DeleteDimensionDimensionsDimensionIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteDimensionDimensionsDimensionIdDeleteResponse, DeleteDimensionDimensionsDimensionIdDeleteError, Options<DeleteDimensionDimensionsDimensionIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDimensionDimensionsDimensionIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readDimensionDimensionsDimensionIdGetQueryKey = (options: Options<ReadDimensionDimensionsDimensionIdGetData>) => createQueryKey('readDimensionDimensionsDimensionIdGet', options, false, [
    'dimensions'
]);

/**
 * Read Dimension
 */
export const readDimensionDimensionsDimensionIdGetOptions = (options: Options<ReadDimensionDimensionsDimensionIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readDimensionDimensionsDimensionIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readDimensionDimensionsDimensionIdGetQueryKey(options)
    });
};

/**
 * Update Dimension
 */
export const updateDimensionDimensionsDimensionIdPutMutation = (options?: Partial<Options<UpdateDimensionDimensionsDimensionIdPutData>>): UseMutationOptions<UpdateDimensionDimensionsDimensionIdPutResponse, UpdateDimensionDimensionsDimensionIdPutError, Options<UpdateDimensionDimensionsDimensionIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateDimensionDimensionsDimensionIdPutResponse, UpdateDimensionDimensionsDimensionIdPutError, Options<UpdateDimensionDimensionsDimensionIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDimensionDimensionsDimensionIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readEndpointsEndpointsGetQueryKey = (options?: Options<ReadEndpointsEndpointsGetData>) => createQueryKey('readEndpointsEndpointsGet', options, false, [
    'endpoints'
]);

/**
 * Read Endpoints
 * Get all endpoints with their related objects
 */
export const readEndpointsEndpointsGetOptions = (options?: Options<ReadEndpointsEndpointsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readEndpointsEndpointsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readEndpointsEndpointsGetQueryKey(options)
    });
};

/**
 * Create Endpoint
 * Create endpoint with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createEndpointEndpointsPostMutation = (options?: Partial<Options<CreateEndpointEndpointsPostData>>): UseMutationOptions<CreateEndpointEndpointsPostResponse, CreateEndpointEndpointsPostError, Options<CreateEndpointEndpointsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateEndpointEndpointsPostResponse, CreateEndpointEndpointsPostError, Options<CreateEndpointEndpointsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createEndpointEndpointsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Endpoint
 */
export const deleteEndpointEndpointsEndpointIdDeleteMutation = (options?: Partial<Options<DeleteEndpointEndpointsEndpointIdDeleteData>>): UseMutationOptions<DeleteEndpointEndpointsEndpointIdDeleteResponse, DeleteEndpointEndpointsEndpointIdDeleteError, Options<DeleteEndpointEndpointsEndpointIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteEndpointEndpointsEndpointIdDeleteResponse, DeleteEndpointEndpointsEndpointIdDeleteError, Options<DeleteEndpointEndpointsEndpointIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteEndpointEndpointsEndpointIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readEndpointEndpointsEndpointIdGetQueryKey = (options: Options<ReadEndpointEndpointsEndpointIdGetData>) => createQueryKey('readEndpointEndpointsEndpointIdGet', options, false, [
    'endpoints'
]);

/**
 * Read Endpoint
 */
export const readEndpointEndpointsEndpointIdGetOptions = (options: Options<ReadEndpointEndpointsEndpointIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readEndpointEndpointsEndpointIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readEndpointEndpointsEndpointIdGetQueryKey(options)
    });
};

/**
 * Update Endpoint
 */
export const updateEndpointEndpointsEndpointIdPutMutation = (options?: Partial<Options<UpdateEndpointEndpointsEndpointIdPutData>>): UseMutationOptions<UpdateEndpointEndpointsEndpointIdPutResponse, UpdateEndpointEndpointsEndpointIdPutError, Options<UpdateEndpointEndpointsEndpointIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateEndpointEndpointsEndpointIdPutResponse, UpdateEndpointEndpointsEndpointIdPutError, Options<UpdateEndpointEndpointsEndpointIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateEndpointEndpointsEndpointIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Invoke Endpoint
 * Invoke an endpoint with the given input data.
 *
 * Args:
 * endpoint_id: The UUID of the endpoint to invoke
 * input_data: Dictionary containing input data for the endpoint
 * db: Database session
 * endpoint_service: The endpoint service instance
 *
 * Returns:
 * The response from the endpoint, either mapped or raw depending on endpoint configuration
 */
export const invokeEndpointEndpointsEndpointIdInvokePostMutation = (options?: Partial<Options<InvokeEndpointEndpointsEndpointIdInvokePostData>>): UseMutationOptions<InvokeEndpointEndpointsEndpointIdInvokePostResponse, InvokeEndpointEndpointsEndpointIdInvokePostError, Options<InvokeEndpointEndpointsEndpointIdInvokePostData>> => {
    const mutationOptions: UseMutationOptions<InvokeEndpointEndpointsEndpointIdInvokePostResponse, InvokeEndpointEndpointsEndpointIdInvokePostError, Options<InvokeEndpointEndpointsEndpointIdInvokePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await invokeEndpointEndpointsEndpointIdInvokePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getEndpointSchemaEndpointsSchemaGetQueryKey = (options?: Options<GetEndpointSchemaEndpointsSchemaGetData>) => createQueryKey('getEndpointSchemaEndpointsSchemaGet', options, false, [
    'endpoints'
]);

/**
 * Get Endpoint Schema
 * Get the endpoint schema definition.
 *
 * Args:
 * endpoint_service: The endpoint service instance
 *
 * Returns:
 * Dict containing the input and output schema definitions
 */
export const getEndpointSchemaEndpointsSchemaGetOptions = (options?: Options<GetEndpointSchemaEndpointsSchemaGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEndpointSchemaEndpointsSchemaGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEndpointSchemaEndpointsSchemaGetQueryKey(options)
    });
};

export const homeHomeGetQueryKey = (options?: Options<HomeHomeGetData>) => createQueryKey('homeHomeGet', options, false, [
    'home'
]);

/**
 * Home
 */
export const homeHomeGetOptions = (options?: Options<HomeHomeGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await homeHomeGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: homeHomeGetQueryKey(options)
    });
};

export const protectedHomeProtectedGetQueryKey = (options?: Options<ProtectedHomeProtectedGetData>) => createQueryKey('protectedHomeProtectedGet', options, false, [
    'home'
]);

/**
 * Protected
 */
export const protectedHomeProtectedGetOptions = (options?: Options<ProtectedHomeProtectedGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await protectedHomeProtectedGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: protectedHomeProtectedGetQueryKey(options)
    });
};

export const readMetricsMetricsGetQueryKey = (options?: Options<ReadMetricsMetricsGetData>) => createQueryKey('readMetricsMetricsGet', options, false, [
    'metrics'
]);

/**
 * Read Metrics
 * Get all metrics with their related objects
 */
export const readMetricsMetricsGetOptions = (options?: Options<ReadMetricsMetricsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readMetricsMetricsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readMetricsMetricsGetQueryKey(options)
    });
};

/**
 * Create Metric
 * Create metric with super optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createMetricMetricsPostMutation = (options?: Partial<Options<CreateMetricMetricsPostData>>): UseMutationOptions<CreateMetricMetricsPostResponse, CreateMetricMetricsPostError, Options<CreateMetricMetricsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateMetricMetricsPostResponse, CreateMetricMetricsPostError, Options<CreateMetricMetricsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createMetricMetricsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Metric
 * Delete a metric
 */
export const deleteMetricMetricsMetricIdDeleteMutation = (options?: Partial<Options<DeleteMetricMetricsMetricIdDeleteData>>): UseMutationOptions<DeleteMetricMetricsMetricIdDeleteResponse, DeleteMetricMetricsMetricIdDeleteError, Options<DeleteMetricMetricsMetricIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteMetricMetricsMetricIdDeleteResponse, DeleteMetricMetricsMetricIdDeleteError, Options<DeleteMetricMetricsMetricIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMetricMetricsMetricIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readMetricMetricsMetricIdGetQueryKey = (options: Options<ReadMetricMetricsMetricIdGetData>) => createQueryKey('readMetricMetricsMetricIdGet', options, false, [
    'metrics'
]);

/**
 * Read Metric
 * Get a specific metric by ID with its related objects
 */
export const readMetricMetricsMetricIdGetOptions = (options: Options<ReadMetricMetricsMetricIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readMetricMetricsMetricIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readMetricMetricsMetricIdGetQueryKey(options)
    });
};

/**
 * Update Metric
 * Update a metric
 */
export const updateMetricMetricsMetricIdPutMutation = (options?: Partial<Options<UpdateMetricMetricsMetricIdPutData>>): UseMutationOptions<UpdateMetricMetricsMetricIdPutResponse, UpdateMetricMetricsMetricIdPutError, Options<UpdateMetricMetricsMetricIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateMetricMetricsMetricIdPutResponse, UpdateMetricMetricsMetricIdPutError, Options<UpdateMetricMetricsMetricIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateMetricMetricsMetricIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Behavior From Metric
 * Remove a behavior from a metric
 */
export const removeBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteMutation = (options?: Partial<Options<RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteData>>): UseMutationOptions<RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteResponse, RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteError, Options<RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteResponse, RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteError, Options<RemoveBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeBehaviorFromMetricMetricsMetricIdBehaviorsBehaviorIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add Behavior To Metric
 * Add a behavior to a metric
 */
export const addBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostMutation = (options?: Partial<Options<AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostData>>): UseMutationOptions<AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostResponse, AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostError, Options<AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostData>> => {
    const mutationOptions: UseMutationOptions<AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostResponse, AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostError, Options<AddBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addBehaviorToMetricMetricsMetricIdBehaviorsBehaviorIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readMetricBehaviorsMetricsMetricIdBehaviorsGetQueryKey = (options: Options<ReadMetricBehaviorsMetricsMetricIdBehaviorsGetData>) => createQueryKey('readMetricBehaviorsMetricsMetricIdBehaviorsGet', options, false, [
    'metrics'
]);

/**
 * Read Metric Behaviors
 * Get all behaviors associated with a metric
 */
export const readMetricBehaviorsMetricsMetricIdBehaviorsGetOptions = (options: Options<ReadMetricBehaviorsMetricsMetricIdBehaviorsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readMetricBehaviorsMetricsMetricIdBehaviorsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readMetricBehaviorsMetricsMetricIdBehaviorsGetQueryKey(options)
    });
};

export const readModelsModelsGetQueryKey = (options?: Options<ReadModelsModelsGetData>) => createQueryKey('readModelsModelsGet', options, false, [
    'models'
]);

/**
 * Read Models
 * Get all models with their related objects
 */
export const readModelsModelsGetOptions = (options?: Options<ReadModelsModelsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readModelsModelsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readModelsModelsGetQueryKey(options)
    });
};

/**
 * Create Model
 * Create model with super optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createModelModelsPostMutation = (options?: Partial<Options<CreateModelModelsPostData>>): UseMutationOptions<CreateModelModelsPostResponse, CreateModelModelsPostError, Options<CreateModelModelsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateModelModelsPostResponse, CreateModelModelsPostError, Options<CreateModelModelsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createModelModelsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Model
 * Delete a model
 */
export const deleteModelModelsModelIdDeleteMutation = (options?: Partial<Options<DeleteModelModelsModelIdDeleteData>>): UseMutationOptions<DeleteModelModelsModelIdDeleteResponse, DeleteModelModelsModelIdDeleteError, Options<DeleteModelModelsModelIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteModelModelsModelIdDeleteResponse, DeleteModelModelsModelIdDeleteError, Options<DeleteModelModelsModelIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteModelModelsModelIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readModelModelsModelIdGetQueryKey = (options: Options<ReadModelModelsModelIdGetData>) => createQueryKey('readModelModelsModelIdGet', options, false, [
    'models'
]);

/**
 * Read Model
 * Get a specific model by ID
 */
export const readModelModelsModelIdGetOptions = (options: Options<ReadModelModelsModelIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readModelModelsModelIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readModelModelsModelIdGetQueryKey(options)
    });
};

/**
 * Update Model
 * Update model with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateModelModelsModelIdPutMutation = (options?: Partial<Options<UpdateModelModelsModelIdPutData>>): UseMutationOptions<UpdateModelModelsModelIdPutResponse, UpdateModelModelsModelIdPutError, Options<UpdateModelModelsModelIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateModelModelsModelIdPutResponse, UpdateModelModelsModelIdPutError, Options<UpdateModelModelsModelIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateModelModelsModelIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test Model Connection
 * Test the connection to the model's endpoint
 */
export const testModelConnectionModelsModelIdTestPostMutation = (options?: Partial<Options<TestModelConnectionModelsModelIdTestPostData>>): UseMutationOptions<TestModelConnectionModelsModelIdTestPostResponse, TestModelConnectionModelsModelIdTestPostError, Options<TestModelConnectionModelsModelIdTestPostData>> => {
    const mutationOptions: UseMutationOptions<TestModelConnectionModelsModelIdTestPostResponse, TestModelConnectionModelsModelIdTestPostError, Options<TestModelConnectionModelsModelIdTestPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await testModelConnectionModelsModelIdTestPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readOrganizationsOrganizationsGetQueryKey = (options?: Options<ReadOrganizationsOrganizationsGetData>) => createQueryKey('readOrganizationsOrganizationsGet', options, false, [
    'organizations'
]);

/**
 * Read Organizations
 * Get all organizations with their related objects
 */
export const readOrganizationsOrganizationsGetOptions = (options?: Options<ReadOrganizationsOrganizationsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readOrganizationsOrganizationsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readOrganizationsOrganizationsGetQueryKey(options)
    });
};

/**
 * Create Organization
 */
export const createOrganizationOrganizationsPostMutation = (options?: Partial<Options<CreateOrganizationOrganizationsPostData>>): UseMutationOptions<CreateOrganizationOrganizationsPostResponse, CreateOrganizationOrganizationsPostError, Options<CreateOrganizationOrganizationsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateOrganizationOrganizationsPostResponse, CreateOrganizationOrganizationsPostError, Options<CreateOrganizationOrganizationsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOrganizationOrganizationsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Organization
 */
export const deleteOrganizationOrganizationsOrganizationIdDeleteMutation = (options?: Partial<Options<DeleteOrganizationOrganizationsOrganizationIdDeleteData>>): UseMutationOptions<DeleteOrganizationOrganizationsOrganizationIdDeleteResponse, DeleteOrganizationOrganizationsOrganizationIdDeleteError, Options<DeleteOrganizationOrganizationsOrganizationIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationOrganizationsOrganizationIdDeleteResponse, DeleteOrganizationOrganizationsOrganizationIdDeleteError, Options<DeleteOrganizationOrganizationsOrganizationIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteOrganizationOrganizationsOrganizationIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readOrganizationOrganizationsOrganizationIdGetQueryKey = (options: Options<ReadOrganizationOrganizationsOrganizationIdGetData>) => createQueryKey('readOrganizationOrganizationsOrganizationIdGet', options, false, [
    'organizations'
]);

/**
 * Read Organization
 */
export const readOrganizationOrganizationsOrganizationIdGetOptions = (options: Options<ReadOrganizationOrganizationsOrganizationIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readOrganizationOrganizationsOrganizationIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readOrganizationOrganizationsOrganizationIdGetQueryKey(options)
    });
};

/**
 * Update Organization
 */
export const updateOrganizationOrganizationsOrganizationIdPutMutation = (options?: Partial<Options<UpdateOrganizationOrganizationsOrganizationIdPutData>>): UseMutationOptions<UpdateOrganizationOrganizationsOrganizationIdPutResponse, UpdateOrganizationOrganizationsOrganizationIdPutError, Options<UpdateOrganizationOrganizationsOrganizationIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateOrganizationOrganizationsOrganizationIdPutResponse, UpdateOrganizationOrganizationsOrganizationIdPutError, Options<UpdateOrganizationOrganizationsOrganizationIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOrganizationOrganizationsOrganizationIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initialize Organization Data
 * Load initial data for an organization if onboarding is not complete.
 */
export const initializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostMutation = (options?: Partial<Options<InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostData>>): UseMutationOptions<InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostResponse, InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostError, Options<InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostData>> => {
    const mutationOptions: UseMutationOptions<InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostResponse, InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostError, Options<InitializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await initializeOrganizationDataOrganizationsOrganizationIdLoadInitialDataPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rollback Organization Data
 * Rollback initial data for an organization.
 */
export const rollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostMutation = (options?: Partial<Options<RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostData>>): UseMutationOptions<RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostResponse, RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostError, Options<RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostData>> => {
    const mutationOptions: UseMutationOptions<RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostResponse, RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostError, Options<RollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rollbackOrganizationDataOrganizationsOrganizationIdRollbackInitialDataPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readProjectsProjectsGetQueryKey = (options?: Options<ReadProjectsProjectsGetData>) => createQueryKey('readProjectsProjectsGet', options, false, [
    'projects'
]);

/**
 * Read Projects
 * Get all projects with their related objects
 */
export const readProjectsProjectsGetOptions = (options?: Options<ReadProjectsProjectsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readProjectsProjectsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readProjectsProjectsGetQueryKey(options)
    });
};

/**
 * Create Project
 * Create project with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createProjectProjectsPostMutation = (options?: Partial<Options<CreateProjectProjectsPostData>>): UseMutationOptions<CreateProjectProjectsPostResponse, CreateProjectProjectsPostError, Options<CreateProjectProjectsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectProjectsPostResponse, CreateProjectProjectsPostError, Options<CreateProjectProjectsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProjectProjectsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Project
 * Delete project with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteProjectProjectsProjectIdDeleteMutation = (options?: Partial<Options<DeleteProjectProjectsProjectIdDeleteData>>): UseMutationOptions<DeleteProjectProjectsProjectIdDeleteResponse, DeleteProjectProjectsProjectIdDeleteError, Options<DeleteProjectProjectsProjectIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectProjectsProjectIdDeleteResponse, DeleteProjectProjectsProjectIdDeleteError, Options<DeleteProjectProjectsProjectIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProjectProjectsProjectIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readProjectProjectsProjectIdGetQueryKey = (options: Options<ReadProjectProjectsProjectIdGetData>) => createQueryKey('readProjectProjectsProjectIdGet', options, false, [
    'projects'
]);

/**
 * Read Project
 * Get project with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readProjectProjectsProjectIdGetOptions = (options: Options<ReadProjectProjectsProjectIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readProjectProjectsProjectIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readProjectProjectsProjectIdGetQueryKey(options)
    });
};

/**
 * Update Project
 * Update project with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateProjectProjectsProjectIdPutMutation = (options?: Partial<Options<UpdateProjectProjectsProjectIdPutData>>): UseMutationOptions<UpdateProjectProjectsProjectIdPutResponse, UpdateProjectProjectsProjectIdPutError, Options<UpdateProjectProjectsProjectIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectProjectsProjectIdPutResponse, UpdateProjectProjectsProjectIdPutError, Options<UpdateProjectProjectsProjectIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProjectProjectsProjectIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readPromptTemplatesPromptTemplatesGetQueryKey = (options?: Options<ReadPromptTemplatesPromptTemplatesGetData>) => createQueryKey('readPromptTemplatesPromptTemplatesGet', options, false, [
    'prompt_templates'
]);

/**
 * Read Prompt Templates
 * Get all prompt templates with their related objects
 */
export const readPromptTemplatesPromptTemplatesGetOptions = (options?: Options<ReadPromptTemplatesPromptTemplatesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readPromptTemplatesPromptTemplatesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readPromptTemplatesPromptTemplatesGetQueryKey(options)
    });
};

/**
 * Create Prompt Template
 * Create prompt template with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createPromptTemplatePromptTemplatesPostMutation = (options?: Partial<Options<CreatePromptTemplatePromptTemplatesPostData>>): UseMutationOptions<CreatePromptTemplatePromptTemplatesPostResponse, CreatePromptTemplatePromptTemplatesPostError, Options<CreatePromptTemplatePromptTemplatesPostData>> => {
    const mutationOptions: UseMutationOptions<CreatePromptTemplatePromptTemplatesPostResponse, CreatePromptTemplatePromptTemplatesPostError, Options<CreatePromptTemplatePromptTemplatesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPromptTemplatePromptTemplatesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Prompt Template
 */
export const deletePromptTemplatePromptTemplatesPromptTemplateIdDeleteMutation = (options?: Partial<Options<DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteData>>): UseMutationOptions<DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteResponse, DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteError, Options<DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteResponse, DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteError, Options<DeletePromptTemplatePromptTemplatesPromptTemplateIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePromptTemplatePromptTemplatesPromptTemplateIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readPromptTemplatePromptTemplatesPromptTemplateIdGetQueryKey = (options: Options<ReadPromptTemplatePromptTemplatesPromptTemplateIdGetData>) => createQueryKey('readPromptTemplatePromptTemplatesPromptTemplateIdGet', options, false, [
    'prompt_templates'
]);

/**
 * Read Prompt Template
 */
export const readPromptTemplatePromptTemplatesPromptTemplateIdGetOptions = (options: Options<ReadPromptTemplatePromptTemplatesPromptTemplateIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readPromptTemplatePromptTemplatesPromptTemplateIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readPromptTemplatePromptTemplatesPromptTemplateIdGetQueryKey(options)
    });
};

/**
 * Update Prompt Template
 */
export const updatePromptTemplatePromptTemplatesPromptTemplateIdPutMutation = (options?: Partial<Options<UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutData>>): UseMutationOptions<UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutResponse, UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutError, Options<UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutResponse, UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutError, Options<UpdatePromptTemplatePromptTemplatesPromptTemplateIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePromptTemplatePromptTemplatesPromptTemplateIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readPromptsPromptsGetQueryKey = (options?: Options<ReadPromptsPromptsGetData>) => createQueryKey('readPromptsPromptsGet', options, false, [
    'prompts'
]);

/**
 * Read Prompts
 * Get all prompts with their related objects
 */
export const readPromptsPromptsGetOptions = (options?: Options<ReadPromptsPromptsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readPromptsPromptsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readPromptsPromptsGetQueryKey(options)
    });
};

/**
 * Create Prompt
 * Create prompt with super optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createPromptPromptsPostMutation = (options?: Partial<Options<CreatePromptPromptsPostData>>): UseMutationOptions<CreatePromptPromptsPostResponse, CreatePromptPromptsPostError, Options<CreatePromptPromptsPostData>> => {
    const mutationOptions: UseMutationOptions<CreatePromptPromptsPostResponse, CreatePromptPromptsPostError, Options<CreatePromptPromptsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPromptPromptsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Prompt
 * Delete a prompt
 */
export const deletePromptPromptsPromptIdDeleteMutation = (options?: Partial<Options<DeletePromptPromptsPromptIdDeleteData>>): UseMutationOptions<DeletePromptPromptsPromptIdDeleteResponse, DeletePromptPromptsPromptIdDeleteError, Options<DeletePromptPromptsPromptIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeletePromptPromptsPromptIdDeleteResponse, DeletePromptPromptsPromptIdDeleteError, Options<DeletePromptPromptsPromptIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePromptPromptsPromptIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readPromptPromptsPromptIdGetQueryKey = (options: Options<ReadPromptPromptsPromptIdGetData>) => createQueryKey('readPromptPromptsPromptIdGet', options, false, [
    'prompts'
]);

/**
 * Read Prompt
 */
export const readPromptPromptsPromptIdGetOptions = (options: Options<ReadPromptPromptsPromptIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readPromptPromptsPromptIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readPromptPromptsPromptIdGetQueryKey(options)
    });
};

/**
 * Update Prompt
 * Update a prompt
 */
export const updatePromptPromptsPromptIdPutMutation = (options?: Partial<Options<UpdatePromptPromptsPromptIdPutData>>): UseMutationOptions<UpdatePromptPromptsPromptIdPutResponse, UpdatePromptPromptsPromptIdPutError, Options<UpdatePromptPromptsPromptIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdatePromptPromptsPromptIdPutResponse, UpdatePromptPromptsPromptIdPutError, Options<UpdatePromptPromptsPromptIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePromptPromptsPromptIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAvailableModelsRecycleModelsGetQueryKey = (options?: Options<ListAvailableModelsRecycleModelsGetData>) => createQueryKey('listAvailableModelsRecycleModelsGet', options, false, [
    'recycle'
]);

/**
 * List Available Models
 * List all available models that can be managed (admin only).
 *
 * Returns:
 * List of model names and their details
 */
export const listAvailableModelsRecycleModelsGetOptions = (options?: Options<ListAvailableModelsRecycleModelsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAvailableModelsRecycleModelsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAvailableModelsRecycleModelsGetQueryKey(options)
    });
};

export const getRecycledRecordsRecycleModelNameGetQueryKey = (options: Options<GetRecycledRecordsRecycleModelNameGetData>) => createQueryKey('getRecycledRecordsRecycleModelNameGet', options, false, [
    'recycle'
]);

/**
 * Get Recycled Records
 * Get soft-deleted records in the recycle bin for a specific model (admin only).
 *
 * Args:
 * model_name: Name of the model (e.g., 'user', 'test', 'project')
 * skip: Number of records to skip
 * limit: Maximum number of records to return
 * organization_id: Optional organization filter
 *
 * Returns:
 * List of soft-deleted records
 */
export const getRecycledRecordsRecycleModelNameGetOptions = (options: Options<GetRecycledRecordsRecycleModelNameGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRecycledRecordsRecycleModelNameGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRecycledRecordsRecycleModelNameGetQueryKey(options)
    });
};

/**
 * Restore From Recycle Bin
 * Restore a soft-deleted record from the recycle bin (admin only).
 *
 * Args:
 * model_name: Name of the model
 * item_id: ID of the record to restore
 * organization_id: Optional organization context
 *
 * Returns:
 * Restored record
 */
export const restoreFromRecycleBinRecycleModelNameItemIdRestorePostMutation = (options?: Partial<Options<RestoreFromRecycleBinRecycleModelNameItemIdRestorePostData>>): UseMutationOptions<RestoreFromRecycleBinRecycleModelNameItemIdRestorePostResponse, RestoreFromRecycleBinRecycleModelNameItemIdRestorePostError, Options<RestoreFromRecycleBinRecycleModelNameItemIdRestorePostData>> => {
    const mutationOptions: UseMutationOptions<RestoreFromRecycleBinRecycleModelNameItemIdRestorePostResponse, RestoreFromRecycleBinRecycleModelNameItemIdRestorePostError, Options<RestoreFromRecycleBinRecycleModelNameItemIdRestorePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restoreFromRecycleBinRecycleModelNameItemIdRestorePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently Delete Record
 * Permanently delete a record from the recycle bin (admin only).
 *
 * WARNING: This action cannot be undone! The record will be permanently
 * removed from the database.
 *
 * Args:
 * model_name: Name of the model
 * item_id: ID of the record to delete
 * confirm: Must be true to confirm permanent deletion
 * organization_id: Optional organization context
 *
 * Returns:
 * Success message
 */
export const permanentlyDeleteRecordRecycleModelNameItemIdDeleteMutation = (options?: Partial<Options<PermanentlyDeleteRecordRecycleModelNameItemIdDeleteData>>): UseMutationOptions<PermanentlyDeleteRecordRecycleModelNameItemIdDeleteResponse, PermanentlyDeleteRecordRecycleModelNameItemIdDeleteError, Options<PermanentlyDeleteRecordRecycleModelNameItemIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<PermanentlyDeleteRecordRecycleModelNameItemIdDeleteResponse, PermanentlyDeleteRecordRecycleModelNameItemIdDeleteError, Options<PermanentlyDeleteRecordRecycleModelNameItemIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await permanentlyDeleteRecordRecycleModelNameItemIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecycleBinCountsRecycleStatsCountsGetQueryKey = (options?: Options<GetRecycleBinCountsRecycleStatsCountsGetData>) => createQueryKey('getRecycleBinCountsRecycleStatsCountsGet', options, false, [
    'recycle'
]);

/**
 * Get Recycle Bin Counts
 * Get counts of soft-deleted records in the recycle bin for all models (admin only).
 *
 * This can take a while for large databases as it queries every table.
 *
 * Args:
 * organization_id: Optional organization filter
 *
 * Returns:
 * Dictionary with counts per model
 */
export const getRecycleBinCountsRecycleStatsCountsGetOptions = (options?: Options<GetRecycleBinCountsRecycleStatsCountsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRecycleBinCountsRecycleStatsCountsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRecycleBinCountsRecycleStatsCountsGetQueryKey(options)
    });
};

/**
 * Bulk Restore From Recycle Bin
 * Restore multiple soft-deleted records from the recycle bin at once (admin only).
 *
 * Args:
 * model_name: Name of the model
 * item_ids: List of IDs to restore
 * organization_id: Optional organization context
 *
 * Returns:
 * Summary of restoration results
 */
export const bulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostMutation = (options?: Partial<Options<BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostData>>): UseMutationOptions<BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostResponse, BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostError, Options<BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostData>> => {
    const mutationOptions: UseMutationOptions<BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostResponse, BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostError, Options<BulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await bulkRestoreFromRecycleBinRecycleBulkRestoreModelNamePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Empty Recycle Bin For Model
 * Empty the recycle bin for a specific model - permanently delete ALL soft-deleted records (admin only).
 *
 * WARNING: This action cannot be undone! All soft-deleted records will be
 * permanently removed from the database.
 *
 * Args:
 * model_name: Name of the model
 * confirm: Must be true to confirm permanent deletion
 * organization_id: Optional organization filter (only delete from this org)
 *
 * Returns:
 * Count of permanently deleted records
 */
export const emptyRecycleBinForModelRecycleEmptyModelNameDeleteMutation = (options?: Partial<Options<EmptyRecycleBinForModelRecycleEmptyModelNameDeleteData>>): UseMutationOptions<EmptyRecycleBinForModelRecycleEmptyModelNameDeleteResponse, EmptyRecycleBinForModelRecycleEmptyModelNameDeleteError, Options<EmptyRecycleBinForModelRecycleEmptyModelNameDeleteData>> => {
    const mutationOptions: UseMutationOptions<EmptyRecycleBinForModelRecycleEmptyModelNameDeleteResponse, EmptyRecycleBinForModelRecycleEmptyModelNameDeleteError, Options<EmptyRecycleBinForModelRecycleEmptyModelNameDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await emptyRecycleBinForModelRecycleEmptyModelNameDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readResponsePatternsResponsePatternsGetQueryKey = (options?: Options<ReadResponsePatternsResponsePatternsGetData>) => createQueryKey('readResponsePatternsResponsePatternsGet', options, false, [
    'response_patterns'
]);

/**
 * Read Response Patterns
 * Get all response patterns with their related objects
 */
export const readResponsePatternsResponsePatternsGetOptions = (options?: Options<ReadResponsePatternsResponsePatternsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readResponsePatternsResponsePatternsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readResponsePatternsResponsePatternsGetQueryKey(options)
    });
};

/**
 * Create Response Pattern
 * Create response pattern with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createResponsePatternResponsePatternsPostMutation = (options?: Partial<Options<CreateResponsePatternResponsePatternsPostData>>): UseMutationOptions<CreateResponsePatternResponsePatternsPostResponse, CreateResponsePatternResponsePatternsPostError, Options<CreateResponsePatternResponsePatternsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateResponsePatternResponsePatternsPostResponse, CreateResponsePatternResponsePatternsPostError, Options<CreateResponsePatternResponsePatternsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createResponsePatternResponsePatternsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Response Pattern
 */
export const deleteResponsePatternResponsePatternsResponsePatternIdDeleteMutation = (options?: Partial<Options<DeleteResponsePatternResponsePatternsResponsePatternIdDeleteData>>): UseMutationOptions<DeleteResponsePatternResponsePatternsResponsePatternIdDeleteResponse, DeleteResponsePatternResponsePatternsResponsePatternIdDeleteError, Options<DeleteResponsePatternResponsePatternsResponsePatternIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteResponsePatternResponsePatternsResponsePatternIdDeleteResponse, DeleteResponsePatternResponsePatternsResponsePatternIdDeleteError, Options<DeleteResponsePatternResponsePatternsResponsePatternIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteResponsePatternResponsePatternsResponsePatternIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readResponsePatternResponsePatternsResponsePatternIdGetQueryKey = (options: Options<ReadResponsePatternResponsePatternsResponsePatternIdGetData>) => createQueryKey('readResponsePatternResponsePatternsResponsePatternIdGet', options, false, [
    'response_patterns'
]);

/**
 * Read Response Pattern
 */
export const readResponsePatternResponsePatternsResponsePatternIdGetOptions = (options: Options<ReadResponsePatternResponsePatternsResponsePatternIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readResponsePatternResponsePatternsResponsePatternIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readResponsePatternResponsePatternsResponsePatternIdGetQueryKey(options)
    });
};

/**
 * Update Response Pattern
 */
export const updateResponsePatternResponsePatternsResponsePatternIdPutMutation = (options?: Partial<Options<UpdateResponsePatternResponsePatternsResponsePatternIdPutData>>): UseMutationOptions<UpdateResponsePatternResponsePatternsResponsePatternIdPutResponse, UpdateResponsePatternResponsePatternsResponsePatternIdPutError, Options<UpdateResponsePatternResponsePatternsResponsePatternIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateResponsePatternResponsePatternsResponsePatternIdPutResponse, UpdateResponsePatternResponsePatternsResponsePatternIdPutError, Options<UpdateResponsePatternResponsePatternsResponsePatternIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateResponsePatternResponsePatternsResponsePatternIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readRisksRisksGetQueryKey = (options?: Options<ReadRisksRisksGetData>) => createQueryKey('readRisksRisksGet', options, false, [
    'risks'
]);

/**
 * Read Risks
 * Get all risks with their related objects
 */
export const readRisksRisksGetOptions = (options?: Options<ReadRisksRisksGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readRisksRisksGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readRisksRisksGetQueryKey(options)
    });
};

/**
 * Create Risk
 * Create risk with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createRiskRisksPostMutation = (options?: Partial<Options<CreateRiskRisksPostData>>): UseMutationOptions<CreateRiskRisksPostResponse, CreateRiskRisksPostError, Options<CreateRiskRisksPostData>> => {
    const mutationOptions: UseMutationOptions<CreateRiskRisksPostResponse, CreateRiskRisksPostError, Options<CreateRiskRisksPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRiskRisksPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Risk
 */
export const deleteRiskRisksRiskIdDeleteMutation = (options?: Partial<Options<DeleteRiskRisksRiskIdDeleteData>>): UseMutationOptions<DeleteRiskRisksRiskIdDeleteResponse, DeleteRiskRisksRiskIdDeleteError, Options<DeleteRiskRisksRiskIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteRiskRisksRiskIdDeleteResponse, DeleteRiskRisksRiskIdDeleteError, Options<DeleteRiskRisksRiskIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRiskRisksRiskIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readRiskRisksRiskIdGetQueryKey = (options: Options<ReadRiskRisksRiskIdGetData>) => createQueryKey('readRiskRisksRiskIdGet', options, false, [
    'risks'
]);

/**
 * Read Risk
 */
export const readRiskRisksRiskIdGetOptions = (options: Options<ReadRiskRisksRiskIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readRiskRisksRiskIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readRiskRisksRiskIdGetQueryKey(options)
    });
};

/**
 * Update Risk
 * Update risk with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateRiskRisksRiskIdPutMutation = (options?: Partial<Options<UpdateRiskRisksRiskIdPutData>>): UseMutationOptions<UpdateRiskRisksRiskIdPutResponse, UpdateRiskRisksRiskIdPutError, Options<UpdateRiskRisksRiskIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateRiskRisksRiskIdPutResponse, UpdateRiskRisksRiskIdPutError, Options<UpdateRiskRisksRiskIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRiskRisksRiskIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGithubContentsServicesGithubContentsGetQueryKey = (options: Options<GetGithubContentsServicesGithubContentsGetData>) => createQueryKey('getGithubContentsServicesGithubContentsGet', options, false, [
    'services'
]);

/**
 * Get Github Contents
 * Get the contents of a GitHub repository.
 */
export const getGithubContentsServicesGithubContentsGetOptions = (options: Options<GetGithubContentsServicesGithubContentsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGithubContentsServicesGithubContentsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGithubContentsServicesGithubContentsGetQueryKey(options)
    });
};

/**
 * Get Ai Json Response
 * Get a JSON response from the LLM (SSE if `stream=True`).
 */
export const getAiJsonResponseServicesOpenaiJsonPostMutation = (options?: Partial<Options<GetAiJsonResponseServicesOpenaiJsonPostData>>): UseMutationOptions<GetAiJsonResponseServicesOpenaiJsonPostResponse, GetAiJsonResponseServicesOpenaiJsonPostError, Options<GetAiJsonResponseServicesOpenaiJsonPostData>> => {
    const mutationOptions: UseMutationOptions<GetAiJsonResponseServicesOpenaiJsonPostResponse, GetAiJsonResponseServicesOpenaiJsonPostError, Options<GetAiJsonResponseServicesOpenaiJsonPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getAiJsonResponseServicesOpenaiJsonPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get Ai Chat Response
 * Chat endpoint:
 * - SSE stream when `stream=True`
 * - JSON shape (LLM-structured) OR TextResponse when not streaming
 */
export const getAiChatResponseServicesOpenaiChatPostMutation = (options?: Partial<Options<GetAiChatResponseServicesOpenaiChatPostData>>): UseMutationOptions<GetAiChatResponseServicesOpenaiChatPostResponse, GetAiChatResponseServicesOpenaiChatPostError, Options<GetAiChatResponseServicesOpenaiChatPostData>> => {
    const mutationOptions: UseMutationOptions<GetAiChatResponseServicesOpenaiChatPostResponse, GetAiChatResponseServicesOpenaiChatPostError, Options<GetAiChatResponseServicesOpenaiChatPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getAiChatResponseServicesOpenaiChatPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Chat Completion Endpoint
 * OpenAI-compatible Chat Completions API (SSE if `stream=True`).
 */
export const createChatCompletionEndpointServicesChatCompletionsPostMutation = (options?: Partial<Options<CreateChatCompletionEndpointServicesChatCompletionsPostData>>): UseMutationOptions<CreateChatCompletionEndpointServicesChatCompletionsPostResponse, CreateChatCompletionEndpointServicesChatCompletionsPostError, Options<CreateChatCompletionEndpointServicesChatCompletionsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateChatCompletionEndpointServicesChatCompletionsPostResponse, CreateChatCompletionEndpointServicesChatCompletionsPostError, Options<CreateChatCompletionEndpointServicesChatCompletionsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createChatCompletionEndpointServicesChatCompletionsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate Content Endpoint
 * Generate text using the LLM; if `schema_` is provided, returns validated JSON.
 */
export const generateContentEndpointServicesGenerateContentPostMutation = (options?: Partial<Options<GenerateContentEndpointServicesGenerateContentPostData>>): UseMutationOptions<GenerateContentEndpointServicesGenerateContentPostResponse, GenerateContentEndpointServicesGenerateContentPostError, Options<GenerateContentEndpointServicesGenerateContentPostData>> => {
    const mutationOptions: UseMutationOptions<GenerateContentEndpointServicesGenerateContentPostResponse, GenerateContentEndpointServicesGenerateContentPostError, Options<GenerateContentEndpointServicesGenerateContentPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateContentEndpointServicesGenerateContentPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate Tests Endpoint
 * Generate test cases using the prompt synthesizer.
 */
export const generateTestsEndpointServicesGenerateTestsPostMutation = (options?: Partial<Options<GenerateTestsEndpointServicesGenerateTestsPostData>>): UseMutationOptions<GenerateTestsEndpointServicesGenerateTestsPostResponse, GenerateTestsEndpointServicesGenerateTestsPostError, Options<GenerateTestsEndpointServicesGenerateTestsPostData>> => {
    const mutationOptions: UseMutationOptions<GenerateTestsEndpointServicesGenerateTestsPostResponse, GenerateTestsEndpointServicesGenerateTestsPostError, Options<GenerateTestsEndpointServicesGenerateTestsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateTestsEndpointServicesGenerateTestsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate Text
 * Generate raw text from a prompt:
 * - SSE stream when `stream=True`
 * - TextResponse JSON otherwise
 */
export const generateTextServicesGenerateTextPostMutation = (options?: Partial<Options<GenerateTextServicesGenerateTextPostData>>): UseMutationOptions<GenerateTextServicesGenerateTextPostResponse, GenerateTextServicesGenerateTextPostError, Options<GenerateTextServicesGenerateTextPostData>> => {
    const mutationOptions: UseMutationOptions<GenerateTextServicesGenerateTextPostResponse, GenerateTextServicesGenerateTextPostError, Options<GenerateTextServicesGenerateTextPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateTextServicesGenerateTextPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Document
 */
export const uploadDocumentServicesDocumentsUploadPostMutation = (options?: Partial<Options<UploadDocumentServicesDocumentsUploadPostData>>): UseMutationOptions<UploadDocumentServicesDocumentsUploadPostResponse, UploadDocumentServicesDocumentsUploadPostError, Options<UploadDocumentServicesDocumentsUploadPostData>> => {
    const mutationOptions: UseMutationOptions<UploadDocumentServicesDocumentsUploadPostResponse, UploadDocumentServicesDocumentsUploadPostError, Options<UploadDocumentServicesDocumentsUploadPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadDocumentServicesDocumentsUploadPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Extract Document Content
 * Extract text content from an uploaded document.
 */
export const extractDocumentContentServicesDocumentsExtractPostMutation = (options?: Partial<Options<ExtractDocumentContentServicesDocumentsExtractPostData>>): UseMutationOptions<ExtractDocumentContentServicesDocumentsExtractPostResponse, ExtractDocumentContentServicesDocumentsExtractPostError, Options<ExtractDocumentContentServicesDocumentsExtractPostData>> => {
    const mutationOptions: UseMutationOptions<ExtractDocumentContentServicesDocumentsExtractPostResponse, ExtractDocumentContentServicesDocumentsExtractPostError, Options<ExtractDocumentContentServicesDocumentsExtractPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await extractDocumentContentServicesDocumentsExtractPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate Test Config
 * Generate test configuration JSON based on user description.
 */
export const generateTestConfigServicesGenerateTestConfigPostMutation = (options?: Partial<Options<GenerateTestConfigServicesGenerateTestConfigPostData>>): UseMutationOptions<GenerateTestConfigServicesGenerateTestConfigPostResponse, GenerateTestConfigServicesGenerateTestConfigPostError, Options<GenerateTestConfigServicesGenerateTestConfigPostData>> => {
    const mutationOptions: UseMutationOptions<GenerateTestConfigServicesGenerateTestConfigPostResponse, GenerateTestConfigServicesGenerateTestConfigPostError, Options<GenerateTestConfigServicesGenerateTestConfigPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateTestConfigServicesGenerateTestConfigPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readSourcesSourcesGetQueryKey = (options?: Options<ReadSourcesSourcesGetData>) => createQueryKey('readSourcesSourcesGet', options, false, [
    'sources'
]);

/**
 * Read Sources
 * Get all sources with their related objects
 */
export const readSourcesSourcesGetOptions = (options?: Options<ReadSourcesSourcesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readSourcesSourcesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readSourcesSourcesGetQueryKey(options)
    });
};

/**
 * Create Source
 * Create source with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createSourceSourcesPostMutation = (options?: Partial<Options<CreateSourceSourcesPostData>>): UseMutationOptions<CreateSourceSourcesPostResponse, CreateSourceSourcesPostError, Options<CreateSourceSourcesPostData>> => {
    const mutationOptions: UseMutationOptions<CreateSourceSourcesPostResponse, CreateSourceSourcesPostError, Options<CreateSourceSourcesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSourceSourcesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Source
 * Delete source with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteSourceSourcesSourceIdDeleteMutation = (options?: Partial<Options<DeleteSourceSourcesSourceIdDeleteData>>): UseMutationOptions<DeleteSourceSourcesSourceIdDeleteResponse, DeleteSourceSourcesSourceIdDeleteError, Options<DeleteSourceSourcesSourceIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteSourceSourcesSourceIdDeleteResponse, DeleteSourceSourcesSourceIdDeleteError, Options<DeleteSourceSourcesSourceIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSourceSourcesSourceIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readSourceSourcesSourceIdGetQueryKey = (options: Options<ReadSourceSourcesSourceIdGetData>) => createQueryKey('readSourceSourcesSourceIdGet', options, false, [
    'sources'
]);

/**
 * Read Source
 * Get source with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readSourceSourcesSourceIdGetOptions = (options: Options<ReadSourceSourcesSourceIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readSourceSourcesSourceIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readSourceSourcesSourceIdGetQueryKey(options)
    });
};

/**
 * Update Source
 * Update source with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateSourceSourcesSourceIdPutMutation = (options?: Partial<Options<UpdateSourceSourcesSourceIdPutData>>): UseMutationOptions<UpdateSourceSourcesSourceIdPutResponse, UpdateSourceSourcesSourceIdPutError, Options<UpdateSourceSourcesSourceIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateSourceSourcesSourceIdPutResponse, UpdateSourceSourcesSourceIdPutError, Options<UpdateSourceSourcesSourceIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSourceSourcesSourceIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readStatusesStatusesGetQueryKey = (options?: Options<ReadStatusesStatusesGetData>) => createQueryKey('readStatusesStatusesGet', options, false, [
    'statuses'
]);

/**
 * Read Statuses
 * Get all statuses with their related objects
 */
export const readStatusesStatusesGetOptions = (options?: Options<ReadStatusesStatusesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readStatusesStatusesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readStatusesStatusesGetQueryKey(options)
    });
};

/**
 * Create Status
 * Create status with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createStatusStatusesPostMutation = (options?: Partial<Options<CreateStatusStatusesPostData>>): UseMutationOptions<CreateStatusStatusesPostResponse, CreateStatusStatusesPostError, Options<CreateStatusStatusesPostData>> => {
    const mutationOptions: UseMutationOptions<CreateStatusStatusesPostResponse, CreateStatusStatusesPostError, Options<CreateStatusStatusesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createStatusStatusesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Status
 * Delete status with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteStatusStatusesStatusIdDeleteMutation = (options?: Partial<Options<DeleteStatusStatusesStatusIdDeleteData>>): UseMutationOptions<DeleteStatusStatusesStatusIdDeleteResponse, DeleteStatusStatusesStatusIdDeleteError, Options<DeleteStatusStatusesStatusIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteStatusStatusesStatusIdDeleteResponse, DeleteStatusStatusesStatusIdDeleteError, Options<DeleteStatusStatusesStatusIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteStatusStatusesStatusIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readStatusStatusesStatusIdGetQueryKey = (options: Options<ReadStatusStatusesStatusIdGetData>) => createQueryKey('readStatusStatusesStatusIdGet', options, false, [
    'statuses'
]);

/**
 * Read Status
 * Get status with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readStatusStatusesStatusIdGetOptions = (options: Options<ReadStatusStatusesStatusIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readStatusStatusesStatusIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readStatusStatusesStatusIdGetQueryKey(options)
    });
};

/**
 * Update Status
 * Update status with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateStatusStatusesStatusIdPutMutation = (options?: Partial<Options<UpdateStatusStatusesStatusIdPutData>>): UseMutationOptions<UpdateStatusStatusesStatusIdPutResponse, UpdateStatusStatusesStatusIdPutError, Options<UpdateStatusStatusesStatusIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateStatusStatusesStatusIdPutResponse, UpdateStatusStatusesStatusIdPutError, Options<UpdateStatusStatusesStatusIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateStatusStatusesStatusIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTagsTagsGetQueryKey = (options?: Options<ReadTagsTagsGetData>) => createQueryKey('readTagsTagsGet', options, false, [
    'tags'
]);

/**
 * Read Tags
 * Get all tags with their related objects
 */
export const readTagsTagsGetOptions = (options?: Options<ReadTagsTagsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTagsTagsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTagsTagsGetQueryKey(options)
    });
};

/**
 * Create Tag
 * Create tag with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTagTagsPostMutation = (options?: Partial<Options<CreateTagTagsPostData>>): UseMutationOptions<CreateTagTagsPostResponse, CreateTagTagsPostError, Options<CreateTagTagsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTagTagsPostResponse, CreateTagTagsPostError, Options<CreateTagTagsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTagTagsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Tag
 * Delete tag with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during deletion
 * - Direct tenant context injection
 */
export const deleteTagTagsTagIdDeleteMutation = (options?: Partial<Options<DeleteTagTagsTagIdDeleteData>>): UseMutationOptions<DeleteTagTagsTagIdDeleteResponse, DeleteTagTagsTagIdDeleteError, Options<DeleteTagTagsTagIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagTagsTagIdDeleteResponse, DeleteTagTagsTagIdDeleteError, Options<DeleteTagTagsTagIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTagTagsTagIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTagTagsTagIdGetQueryKey = (options: Options<ReadTagTagsTagIdGetData>) => createQueryKey('readTagTagsTagIdGet', options, false, [
    'tags'
]);

/**
 * Read Tag
 * Get tag with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during retrieval
 * - Direct tenant context injection
 */
export const readTagTagsTagIdGetOptions = (options: Options<ReadTagTagsTagIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTagTagsTagIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTagTagsTagIdGetQueryKey(options)
    });
};

/**
 * Update Tag
 * Update tag with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTagTagsTagIdPutMutation = (options?: Partial<Options<UpdateTagTagsTagIdPutData>>): UseMutationOptions<UpdateTagTagsTagIdPutResponse, UpdateTagTagsTagIdPutError, Options<UpdateTagTagsTagIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagTagsTagIdPutResponse, UpdateTagTagsTagIdPutError, Options<UpdateTagTagsTagIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTagTagsTagIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Assign Tag To Entity
 * Assign a tag to a specific entity
 */
export const assignTagToEntityTagsEntityTypeEntityIdPostMutation = (options?: Partial<Options<AssignTagToEntityTagsEntityTypeEntityIdPostData>>): UseMutationOptions<AssignTagToEntityTagsEntityTypeEntityIdPostResponse, AssignTagToEntityTagsEntityTypeEntityIdPostError, Options<AssignTagToEntityTagsEntityTypeEntityIdPostData>> => {
    const mutationOptions: UseMutationOptions<AssignTagToEntityTagsEntityTypeEntityIdPostResponse, AssignTagToEntityTagsEntityTypeEntityIdPostError, Options<AssignTagToEntityTagsEntityTypeEntityIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await assignTagToEntityTagsEntityTypeEntityIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Tag From Entity
 * Remove a tag from a specific entity
 */
export const removeTagFromEntityTagsEntityTypeEntityIdTagIdDeleteMutation = (options?: Partial<Options<RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteData>>): UseMutationOptions<RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteResponse, RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteError, Options<RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteResponse, RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteError, Options<RemoveTagFromEntityTagsEntityTypeEntityIdTagIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeTagFromEntityTagsEntityTypeEntityIdTagIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTasksTasksGetQueryKey = (options?: Options<ListTasksTasksGetData>) => createQueryKey('listTasksTasksGet', options, false, [
    'tasks'
]);

/**
 * List Tasks
 * List tasks with filtering, sorting, and comment counts
 */
export const listTasksTasksGetOptions = (options?: Options<ListTasksTasksGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTasksTasksGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTasksTasksGetQueryKey(options)
    });
};

/**
 * Create Task
 * Create a new task
 */
export const createTaskTasksPostMutation = (options?: Partial<Options<CreateTaskTasksPostData>>): UseMutationOptions<CreateTaskTasksPostResponse, CreateTaskTasksPostError, Options<CreateTaskTasksPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTaskTasksPostResponse, CreateTaskTasksPostError, Options<CreateTaskTasksPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTaskTasksPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Task
 * Delete a task
 */
export const deleteTaskTasksTaskIdDeleteMutation = (options?: Partial<Options<DeleteTaskTasksTaskIdDeleteData>>): UseMutationOptions<DeleteTaskTasksTaskIdDeleteResponse, DeleteTaskTasksTaskIdDeleteError, Options<DeleteTaskTasksTaskIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTaskTasksTaskIdDeleteResponse, DeleteTaskTasksTaskIdDeleteError, Options<DeleteTaskTasksTaskIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTaskTasksTaskIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTaskTasksTaskIdGetQueryKey = (options: Options<GetTaskTasksTaskIdGetData>) => createQueryKey('getTaskTasksTaskIdGet', options, false, [
    'tasks'
]);

/**
 * Get Task
 * Get a single task by ID
 */
export const getTaskTasksTaskIdGetOptions = (options: Options<GetTaskTasksTaskIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTaskTasksTaskIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTaskTasksTaskIdGetQueryKey(options)
    });
};

/**
 * Update Task
 * Update a task
 */
export const updateTaskTasksTaskIdPatchMutation = (options?: Partial<Options<UpdateTaskTasksTaskIdPatchData>>): UseMutationOptions<UpdateTaskTasksTaskIdPatchResponse, UpdateTaskTasksTaskIdPatchError, Options<UpdateTaskTasksTaskIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateTaskTasksTaskIdPatchResponse, UpdateTaskTasksTaskIdPatchError, Options<UpdateTaskTasksTaskIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTaskTasksTaskIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTasksByEntityTasksEntityTypeEntityIdGetQueryKey = (options: Options<GetTasksByEntityTasksEntityTypeEntityIdGetData>) => createQueryKey('getTasksByEntityTasksEntityTypeEntityIdGet', options, false, [
    'tasks'
]);

/**
 * Get Tasks By Entity
 * Get tasks by entity type and entity ID
 */
export const getTasksByEntityTasksEntityTypeEntityIdGetOptions = (options: Options<GetTasksByEntityTasksEntityTypeEntityIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTasksByEntityTasksEntityTypeEntityIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTasksByEntityTasksEntityTypeEntityIdGetQueryKey(options)
    });
};

export const readTestContextsTestContextsGetQueryKey = (options?: Options<ReadTestContextsTestContextsGetData>) => createQueryKey('readTestContextsTestContextsGet', options, false, [
    'test contexts'
]);

/**
 * Read Test Contexts
 * Get all test contexts or filter by test_id
 */
export const readTestContextsTestContextsGetOptions = (options?: Options<ReadTestContextsTestContextsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestContextsTestContextsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestContextsTestContextsGetQueryKey(options)
    });
};

/**
 * Create Test Context
 * Create test context with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTestContextTestContextsPostMutation = (options?: Partial<Options<CreateTestContextTestContextsPostData>>): UseMutationOptions<CreateTestContextTestContextsPostResponse, CreateTestContextTestContextsPostError, Options<CreateTestContextTestContextsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestContextTestContextsPostResponse, CreateTestContextTestContextsPostError, Options<CreateTestContextTestContextsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestContextTestContextsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Test Context
 * Delete a test context
 */
export const deleteTestContextTestContextsTestContextIdDeleteMutation = (options?: Partial<Options<DeleteTestContextTestContextsTestContextIdDeleteData>>): UseMutationOptions<DeleteTestContextTestContextsTestContextIdDeleteResponse, DeleteTestContextTestContextsTestContextIdDeleteError, Options<DeleteTestContextTestContextsTestContextIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestContextTestContextsTestContextIdDeleteResponse, DeleteTestContextTestContextsTestContextIdDeleteError, Options<DeleteTestContextTestContextsTestContextIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestContextTestContextsTestContextIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestContextTestContextsTestContextIdGetQueryKey = (options: Options<ReadTestContextTestContextsTestContextIdGetData>) => createQueryKey('readTestContextTestContextsTestContextIdGet', options, false, [
    'test contexts'
]);

/**
 * Read Test Context
 * Get a specific test context by ID
 */
export const readTestContextTestContextsTestContextIdGetOptions = (options: Options<ReadTestContextTestContextsTestContextIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestContextTestContextsTestContextIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestContextTestContextsTestContextIdGetQueryKey(options)
    });
};

/**
 * Update Test Context
 * Update test_context with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTestContextTestContextsTestContextIdPutMutation = (options?: Partial<Options<UpdateTestContextTestContextsTestContextIdPutData>>): UseMutationOptions<UpdateTestContextTestContextsTestContextIdPutResponse, UpdateTestContextTestContextsTestContextIdPutError, Options<UpdateTestContextTestContextsTestContextIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestContextTestContextsTestContextIdPutResponse, UpdateTestContextTestContextsTestContextIdPutError, Options<UpdateTestContextTestContextsTestContextIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestContextTestContextsTestContextIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestConfigurationsTestConfigurationsGetQueryKey = (options?: Options<ReadTestConfigurationsTestConfigurationsGetData>) => createQueryKey('readTestConfigurationsTestConfigurationsGet', options, false, [
    'test_configurations'
]);

/**
 * Read Test Configurations
 * Get all test configurations with their related objects
 */
export const readTestConfigurationsTestConfigurationsGetOptions = (options?: Options<ReadTestConfigurationsTestConfigurationsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestConfigurationsTestConfigurationsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestConfigurationsTestConfigurationsGetQueryKey(options)
    });
};

/**
 * Create Test Configuration
 * Create test configuration with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTestConfigurationTestConfigurationsPostMutation = (options?: Partial<Options<CreateTestConfigurationTestConfigurationsPostData>>): UseMutationOptions<CreateTestConfigurationTestConfigurationsPostResponse, CreateTestConfigurationTestConfigurationsPostError, Options<CreateTestConfigurationTestConfigurationsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestConfigurationTestConfigurationsPostResponse, CreateTestConfigurationTestConfigurationsPostError, Options<CreateTestConfigurationTestConfigurationsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestConfigurationTestConfigurationsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Test Configuration
 * Delete a test configuration
 */
export const deleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteMutation = (options?: Partial<Options<DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteData>>): UseMutationOptions<DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteResponse, DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteError, Options<DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteResponse, DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteError, Options<DeleteTestConfigurationTestConfigurationsTestConfigurationIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestConfigurationTestConfigurationsTestConfigurationIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestConfigurationTestConfigurationsTestConfigurationIdGetQueryKey = (options: Options<ReadTestConfigurationTestConfigurationsTestConfigurationIdGetData>) => createQueryKey('readTestConfigurationTestConfigurationsTestConfigurationIdGet', options, false, [
    'test_configurations'
]);

/**
 * Read Test Configuration
 * Get a specific test configuration by ID with its related objects
 */
export const readTestConfigurationTestConfigurationsTestConfigurationIdGetOptions = (options: Options<ReadTestConfigurationTestConfigurationsTestConfigurationIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestConfigurationTestConfigurationsTestConfigurationIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestConfigurationTestConfigurationsTestConfigurationIdGetQueryKey(options)
    });
};

/**
 * Update Test Configuration
 * Update test_configuration with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTestConfigurationTestConfigurationsTestConfigurationIdPutMutation = (options?: Partial<Options<UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutData>>): UseMutationOptions<UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutResponse, UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutError, Options<UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutResponse, UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutError, Options<UpdateTestConfigurationTestConfigurationsTestConfigurationIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestConfigurationTestConfigurationsTestConfigurationIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Execute Test Configuration Endpoint
 * Execute a test configuration by running its test set.
 */
export const executeTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostMutation = (options?: Partial<Options<ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostData>>): UseMutationOptions<ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostResponse, ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostError, Options<ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostData>> => {
    const mutationOptions: UseMutationOptions<ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostResponse, ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostError, Options<ExecuteTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await executeTestConfigurationEndpointTestConfigurationsTestConfigurationIdExecutePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestResultsTestResultsGetQueryKey = (options?: Options<ReadTestResultsTestResultsGetData>) => createQueryKey('readTestResultsTestResultsGet', options, false, [
    'test_results'
]);

/**
 * Read Test Results
 * Get all test results
 */
export const readTestResultsTestResultsGetOptions = (options?: Options<ReadTestResultsTestResultsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestResultsTestResultsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestResultsTestResultsGetQueryKey(options)
    });
};

/**
 * Create Test Result
 * Create test result with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTestResultTestResultsPostMutation = (options?: Partial<Options<CreateTestResultTestResultsPostData>>): UseMutationOptions<CreateTestResultTestResultsPostResponse, CreateTestResultTestResultsPostError, Options<CreateTestResultTestResultsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestResultTestResultsPostResponse, CreateTestResultTestResultsPostError, Options<CreateTestResultTestResultsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestResultTestResultsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateTestResultStatsTestResultsStatsGetQueryKey = (options?: Options<GenerateTestResultStatsTestResultsStatsGetData>) => createQueryKey('generateTestResultStatsTestResultsStatsGet', options, false, [
    'test_results'
]);

/**
 * Generate Test Result Stats
 * Get test result statistics with configurable data modes for optimal performance
 *
 * ## Available Modes
 *
 * ### Performance-Optimized Modes (recommended for specific use cases):
 *
 * **`summary`** - Ultra-lightweight (~5% of full data size)
 * - Returns: `overall_pass_rates` + `metadata`
 * - Use case: Dashboard widgets, quick overviews
 * - Response time: ~50ms
 *
 * **`metrics`** - Individual metric analysis (~20% of full data size)
 * - Returns: `metric_pass_rates` + `metadata`
 * - Contains: Pass/fail rates for Answer Fluency, Answer Relevancy, Contextual Recall, etc.
 * - Use case: Metric-focused charts, AI model performance analysis
 *
 * **`behavior`** - Test behavior analysis (~15% of full data size)
 * - Returns: `behavior_pass_rates` + `metadata`
 * - Contains: Pass/fail rates grouped by test behavior (Factual Accuracy, Reasoning, etc.)
 * - Use case: Behavior performance charts, test strategy optimization
 *
 * **`category`** - Test category analysis (~15% of full data size)
 * - Returns: `category_pass_rates` + `metadata`
 * - Contains: Pass/fail rates grouped by test category (RAG Systems, Chatbots, etc.)
 * - Use case: Category performance comparison, domain-specific analysis
 *
 * **`topic`** - Test topic analysis (~15% of full data size)
 * - Returns: `topic_pass_rates` + `metadata`
 * - Contains: Pass/fail rates grouped by topic (Healthcare, Finance, Technology, etc.)
 * - Use case: Topic performance insights, domain expertise evaluation
 *
 * **`overall`** - High-level overview (~10% of full data size)
 * - Returns: `overall_pass_rates` + `metadata`
 * - Contains: Aggregate pass/fail rates (test passes only if ALL metrics pass)
 * - Use case: Executive dashboards, KPI tracking
 *
 * **`timeline`** - Trend analysis (~40% of full data size)
 * - Returns: `timeline` + `metadata`
 * - Contains: Monthly pass/fail rates over time with metric breakdowns
 * - Use case: Trend charts, historical analysis, progress tracking
 *
 * **`test_runs`** - Test run comparison (~30% of full data size)
 * - Returns: `test_run_summary` + `metadata`
 * - Contains: Pass/fail rates grouped by individual test runs
 * - Use case: Test run comparison, execution analysis
 *
 * ### Complete Dataset Mode:
 *
 * **`all`** - Complete dataset (default, full data size)
 * - Returns: All sections above combined
 * - Use case: Comprehensive dashboards, full analytics
 * - Response time: ~200-500ms depending on data volume
 */
export const generateTestResultStatsTestResultsStatsGetOptions = (options?: Options<GenerateTestResultStatsTestResultsStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateTestResultStatsTestResultsStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateTestResultStatsTestResultsStatsGetQueryKey(options)
    });
};

/**
 * Delete Test Result
 * Delete a test result
 */
export const deleteTestResultTestResultsTestResultIdDeleteMutation = (options?: Partial<Options<DeleteTestResultTestResultsTestResultIdDeleteData>>): UseMutationOptions<DeleteTestResultTestResultsTestResultIdDeleteResponse, DeleteTestResultTestResultsTestResultIdDeleteError, Options<DeleteTestResultTestResultsTestResultIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestResultTestResultsTestResultIdDeleteResponse, DeleteTestResultTestResultsTestResultIdDeleteError, Options<DeleteTestResultTestResultsTestResultIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestResultTestResultsTestResultIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestResultTestResultsTestResultIdGetQueryKey = (options: Options<ReadTestResultTestResultsTestResultIdGetData>) => createQueryKey('readTestResultTestResultsTestResultIdGet', options, false, [
    'test_results'
]);

/**
 * Read Test Result
 * Get a specific test result by ID
 */
export const readTestResultTestResultsTestResultIdGetOptions = (options: Options<ReadTestResultTestResultsTestResultIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestResultTestResultsTestResultIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestResultTestResultsTestResultIdGetQueryKey(options)
    });
};

/**
 * Update Test Result
 * Update test_result with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTestResultTestResultsTestResultIdPutMutation = (options?: Partial<Options<UpdateTestResultTestResultsTestResultIdPutData>>): UseMutationOptions<UpdateTestResultTestResultsTestResultIdPutResponse, UpdateTestResultTestResultsTestResultIdPutError, Options<UpdateTestResultTestResultsTestResultIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestResultTestResultsTestResultIdPutResponse, UpdateTestResultTestResultsTestResultIdPutError, Options<UpdateTestResultTestResultsTestResultIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestResultTestResultsTestResultIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestRunsTestRunsGetQueryKey = (options?: Options<ReadTestRunsTestRunsGetData>) => createQueryKey('readTestRunsTestRunsGet', options, false, [
    'test_runs'
]);

/**
 * Read Test Runs
 * Get all test runs with their related objects
 */
export const readTestRunsTestRunsGetOptions = (options?: Options<ReadTestRunsTestRunsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestRunsTestRunsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestRunsTestRunsGetQueryKey(options)
    });
};

/**
 * Create Test Run
 * Create test run with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTestRunTestRunsPostMutation = (options?: Partial<Options<CreateTestRunTestRunsPostData>>): UseMutationOptions<CreateTestRunTestRunsPostResponse, CreateTestRunTestRunsPostError, Options<CreateTestRunTestRunsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestRunTestRunsPostResponse, CreateTestRunTestRunsPostError, Options<CreateTestRunTestRunsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestRunTestRunsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateTestRunStatsTestRunsStatsGetQueryKey = (options?: Options<GenerateTestRunStatsTestRunsStatsGetData>) => createQueryKey('generateTestRunStatsTestRunsStatsGet', options, false, [
    'test_runs'
]);

/**
 * Generate Test Run Stats
 * Get test run statistics with configurable data modes for optimal performance
 *
 * (See docstring in source for full details)
 */
export const generateTestRunStatsTestRunsStatsGetOptions = (options?: Options<GenerateTestRunStatsTestRunsStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateTestRunStatsTestRunsStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateTestRunStatsTestRunsStatsGetQueryKey(options)
    });
};

/**
 * Delete Test Run
 * Delete a test run
 */
export const deleteTestRunTestRunsTestRunIdDeleteMutation = (options?: Partial<Options<DeleteTestRunTestRunsTestRunIdDeleteData>>): UseMutationOptions<DeleteTestRunTestRunsTestRunIdDeleteResponse, DeleteTestRunTestRunsTestRunIdDeleteError, Options<DeleteTestRunTestRunsTestRunIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestRunTestRunsTestRunIdDeleteResponse, DeleteTestRunTestRunsTestRunIdDeleteError, Options<DeleteTestRunTestRunsTestRunIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestRunTestRunsTestRunIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestRunTestRunsTestRunIdGetQueryKey = (options: Options<ReadTestRunTestRunsTestRunIdGetData>) => createQueryKey('readTestRunTestRunsTestRunIdGet', options, false, [
    'test_runs'
]);

/**
 * Read Test Run
 * Get a specific test run by ID with its related objects
 */
export const readTestRunTestRunsTestRunIdGetOptions = (options: Options<ReadTestRunTestRunsTestRunIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestRunTestRunsTestRunIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestRunTestRunsTestRunIdGetQueryKey(options)
    });
};

/**
 * Update Test Run
 * Update test_run with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTestRunTestRunsTestRunIdPutMutation = (options?: Partial<Options<UpdateTestRunTestRunsTestRunIdPutData>>): UseMutationOptions<UpdateTestRunTestRunsTestRunIdPutResponse, UpdateTestRunTestRunsTestRunIdPutError, Options<UpdateTestRunTestRunsTestRunIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestRunTestRunsTestRunIdPutResponse, UpdateTestRunTestRunsTestRunIdPutError, Options<UpdateTestRunTestRunsTestRunIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestRunTestRunsTestRunIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTestRunBehaviorsTestRunsTestRunIdBehaviorsGetQueryKey = (options: Options<GetTestRunBehaviorsTestRunsTestRunIdBehaviorsGetData>) => createQueryKey('getTestRunBehaviorsTestRunsTestRunIdBehaviorsGet', options, false, [
    'test_runs'
]);

/**
 * Get Test Run Behaviors
 * Get behaviors that have test results for this test run with organization filtering
 */
export const getTestRunBehaviorsTestRunsTestRunIdBehaviorsGetOptions = (options: Options<GetTestRunBehaviorsTestRunsTestRunIdBehaviorsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTestRunBehaviorsTestRunsTestRunIdBehaviorsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTestRunBehaviorsTestRunsTestRunIdBehaviorsGetQueryKey(options)
    });
};

export const downloadTestRunResultsTestRunsTestRunIdDownloadGetQueryKey = (options: Options<DownloadTestRunResultsTestRunsTestRunIdDownloadGetData>) => createQueryKey('downloadTestRunResultsTestRunsTestRunIdDownloadGet', options, false, [
    'test_runs'
]);

/**
 * Download Test Run Results
 * Download test run results as CSV
 */
export const downloadTestRunResultsTestRunsTestRunIdDownloadGetOptions = (options: Options<DownloadTestRunResultsTestRunsTestRunIdDownloadGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadTestRunResultsTestRunsTestRunIdDownloadGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadTestRunResultsTestRunsTestRunIdDownloadGetQueryKey(options)
    });
};

/**
 * Generate Test Set
 */
export const generateTestSetTestSetsGeneratePostMutation = (options?: Partial<Options<GenerateTestSetTestSetsGeneratePostData>>): UseMutationOptions<GenerateTestSetTestSetsGeneratePostResponse, GenerateTestSetTestSetsGeneratePostError, Options<GenerateTestSetTestSetsGeneratePostData>> => {
    const mutationOptions: UseMutationOptions<GenerateTestSetTestSetsGeneratePostResponse, GenerateTestSetTestSetsGeneratePostError, Options<GenerateTestSetTestSetsGeneratePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await generateTestSetTestSetsGeneratePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Test Set Bulk
 */
export const createTestSetBulkTestSetsBulkPostMutation = (options?: Partial<Options<CreateTestSetBulkTestSetsBulkPostData>>): UseMutationOptions<CreateTestSetBulkTestSetsBulkPostResponse, CreateTestSetBulkTestSetsBulkPostError, Options<CreateTestSetBulkTestSetsBulkPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestSetBulkTestSetsBulkPostResponse, CreateTestSetBulkTestSetsBulkPostError, Options<CreateTestSetBulkTestSetsBulkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestSetBulkTestSetsBulkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestSetsTestSetsGetQueryKey = (options?: Options<ReadTestSetsTestSetsGetData>) => createQueryKey('readTestSetsTestSetsGet', options, false, [
    'test_sets'
]);

/**
 * Read Test Sets
 */
export const readTestSetsTestSetsGetOptions = (options?: Options<ReadTestSetsTestSetsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestSetsTestSetsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestSetsTestSetsGetQueryKey(options)
    });
};

/**
 * Create Test Set
 */
export const createTestSetTestSetsPostMutation = (options?: Partial<Options<CreateTestSetTestSetsPostData>>): UseMutationOptions<CreateTestSetTestSetsPostResponse, CreateTestSetTestSetsPostError, Options<CreateTestSetTestSetsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestSetTestSetsPostResponse, CreateTestSetTestSetsPostError, Options<CreateTestSetTestSetsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestSetTestSetsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateTestSetStatsTestSetsStatsGetQueryKey = (options?: Options<GenerateTestSetStatsTestSetsStatsGetData>) => createQueryKey('generateTestSetStatsTestSetsStatsGet', options, false, [
    'test_sets'
]);

/**
 * Generate Test Set Stats
 */
export const generateTestSetStatsTestSetsStatsGetOptions = (options?: Options<GenerateTestSetStatsTestSetsStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateTestSetStatsTestSetsStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateTestSetStatsTestSetsStatsGetQueryKey(options)
    });
};

export const readTestSetTestSetsTestSetIdentifierGetQueryKey = (options: Options<ReadTestSetTestSetsTestSetIdentifierGetData>) => createQueryKey('readTestSetTestSetsTestSetIdentifierGet', options, false, [
    'test_sets'
]);

/**
 * Read Test Set
 */
export const readTestSetTestSetsTestSetIdentifierGetOptions = (options: Options<ReadTestSetTestSetsTestSetIdentifierGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestSetTestSetsTestSetIdentifierGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestSetTestSetsTestSetIdentifierGetQueryKey(options)
    });
};

/**
 * Delete Test Set
 */
export const deleteTestSetTestSetsTestSetIdDeleteMutation = (options?: Partial<Options<DeleteTestSetTestSetsTestSetIdDeleteData>>): UseMutationOptions<DeleteTestSetTestSetsTestSetIdDeleteResponse, DeleteTestSetTestSetsTestSetIdDeleteError, Options<DeleteTestSetTestSetsTestSetIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestSetTestSetsTestSetIdDeleteResponse, DeleteTestSetTestSetsTestSetIdDeleteError, Options<DeleteTestSetTestSetsTestSetIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestSetTestSetsTestSetIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Test Set
 */
export const updateTestSetTestSetsTestSetIdPutMutation = (options?: Partial<Options<UpdateTestSetTestSetsTestSetIdPutData>>): UseMutationOptions<UpdateTestSetTestSetsTestSetIdPutResponse, UpdateTestSetTestSetsTestSetIdPutError, Options<UpdateTestSetTestSetsTestSetIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestSetTestSetsTestSetIdPutResponse, UpdateTestSetTestSetsTestSetIdPutError, Options<UpdateTestSetTestSetsTestSetIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestSetTestSetsTestSetIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetQueryKey = (options: Options<DownloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetData>) => createQueryKey('downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGet', options, false, [
    'test_sets'
]);

/**
 * Download Test Set Prompts
 */
export const downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetOptions = (options: Options<DownloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadTestSetPromptsTestSetsTestSetIdentifierDownloadGetQueryKey(options)
    });
};

export const downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetQueryKey = (options: Options<DownloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetData>) => createQueryKey('downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGet', options, false, [
    'test_sets'
]);

/**
 * Download Test Set Prompts Csv
 */
export const downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetOptions = (options: Options<DownloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadTestSetPromptsCsvTestSetsTestSetIdentifierPromptsDownloadGetQueryKey(options)
    });
};

export const getTestSetPromptsTestSetsTestSetIdentifierPromptsGetQueryKey = (options: Options<GetTestSetPromptsTestSetsTestSetIdentifierPromptsGetData>) => createQueryKey('getTestSetPromptsTestSetsTestSetIdentifierPromptsGet', options, false, [
    'test_sets'
]);

/**
 * Get Test Set Prompts
 */
export const getTestSetPromptsTestSetsTestSetIdentifierPromptsGetOptions = (options: Options<GetTestSetPromptsTestSetsTestSetIdentifierPromptsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTestSetPromptsTestSetsTestSetIdentifierPromptsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTestSetPromptsTestSetsTestSetIdentifierPromptsGetQueryKey(options)
    });
};

export const getTestSetTestsTestSetsTestSetIdentifierTestsGetQueryKey = (options: Options<GetTestSetTestsTestSetsTestSetIdentifierTestsGetData>) => createQueryKey('getTestSetTestsTestSetsTestSetIdentifierTestsGet', options, false, [
    'test_sets'
]);

/**
 * Get Test Set Tests
 */
export const getTestSetTestsTestSetsTestSetIdentifierTestsGetOptions = (options: Options<GetTestSetTestsTestSetsTestSetIdentifierTestsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTestSetTestsTestSetsTestSetIdentifierTestsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTestSetTestsTestSetsTestSetIdentifierTestsGetQueryKey(options)
    });
};

/**
 * Execute Test Set
 * Submit a test set for execution against an endpoint.
 */
export const executeTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostMutation = (options?: Partial<Options<ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostData>>): UseMutationOptions<ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostResponse, ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostError, Options<ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostData>> => {
    const mutationOptions: UseMutationOptions<ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostResponse, ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostError, Options<ExecuteTestSetTestSetsTestSetIdentifierExecuteEndpointIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await executeTestSetTestSetsTestSetIdentifierExecuteEndpointIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateTestSetTestStatsTestSetsTestSetIdentifierStatsGetQueryKey = (options: Options<GenerateTestSetTestStatsTestSetsTestSetIdentifierStatsGetData>) => createQueryKey('generateTestSetTestStatsTestSetsTestSetIdentifierStatsGet', options, false, [
    'test_sets'
]);

/**
 * Generate Test Set Test Stats
 */
export const generateTestSetTestStatsTestSetsTestSetIdentifierStatsGetOptions = (options: Options<GenerateTestSetTestStatsTestSetsTestSetIdentifierStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateTestSetTestStatsTestSetsTestSetIdentifierStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateTestSetTestStatsTestSetsTestSetIdentifierStatsGetQueryKey(options)
    });
};

/**
 * Associate Tests With Test Set
 */
export const associateTestsWithTestSetTestSetsTestSetIdAssociatePostMutation = (options?: Partial<Options<AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostData>>): UseMutationOptions<AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostResponse, AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostError, Options<AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostData>> => {
    const mutationOptions: UseMutationOptions<AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostResponse, AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostError, Options<AssociateTestsWithTestSetTestSetsTestSetIdAssociatePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await associateTestsWithTestSetTestSetsTestSetIdAssociatePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disassociate Tests From Test Set
 */
export const disassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostMutation = (options?: Partial<Options<DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostData>>): UseMutationOptions<DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostResponse, DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostError, Options<DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostData>> => {
    const mutationOptions: UseMutationOptions<DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostResponse, DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostError, Options<DisassociateTestsFromTestSetTestSetsTestSetIdDisassociatePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await disassociateTestsFromTestSetTestSetsTestSetIdDisassociatePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestsTestsGetQueryKey = (options?: Options<ReadTestsTestsGetData>) => createQueryKey('readTestsTestsGet', options, false, [
    'tests'
]);

/**
 * Read Tests
 * Get all tests with their related objects
 */
export const readTestsTestsGetOptions = (options?: Options<ReadTestsTestsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestsTestsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestsTestsGetQueryKey(options)
    });
};

/**
 * Create Test
 * Create test with super optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during entity creation
 * - Direct tenant context injection
 */
export const createTestTestsPostMutation = (options?: Partial<Options<CreateTestTestsPostData>>): UseMutationOptions<CreateTestTestsPostResponse, CreateTestTestsPostError, Options<CreateTestTestsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestTestsPostResponse, CreateTestTestsPostError, Options<CreateTestTestsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestTestsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Tests Bulk
 * Create multiple tests in a single operation.
 *
 * The input format should be:
 * {
 * "tests": [
 * {
 * "prompt": {
 * "content": "Prompt text",
 * "language_code": "en",
 * "demographic": "Optional demographic",
 * "dimension": "Optional dimension",
 * "expected_response": "Optional expected response"
 * },
 * "behavior": "Behavior name",
 * "category": "Category name",
 * "topic": "Topic name",
 * "test_configuration": {},  # Optional test configuration
 * "assignee_id": "uuid",  # Optional assignee ID
 * "owner_id": "uuid",  # Optional owner ID
 * "status": "string",    # Optional status name
 * "priority": "number"   # Optional priority value
 * }
 * ],
 * "test_set_id": "optional-uuid"  # Optional test set ID to associate tests with
 * }
 *
 * Returns:
 * 200: Tests created successfully
 * 400: Invalid request format or validation error
 * 404: Referenced entity not found
 * 500: Server error during processing
 */
export const createTestsBulkTestsBulkPostMutation = (options?: Partial<Options<CreateTestsBulkTestsBulkPostData>>): UseMutationOptions<CreateTestsBulkTestsBulkPostResponse, CreateTestsBulkTestsBulkPostError, Options<CreateTestsBulkTestsBulkPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTestsBulkTestsBulkPostResponse, CreateTestsBulkTestsBulkPostError, Options<CreateTestsBulkTestsBulkPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTestsBulkTestsBulkPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateTestStatsTestsStatsGetQueryKey = (options?: Options<GenerateTestStatsTestsStatsGetData>) => createQueryKey('generateTestStatsTestsStatsGet', options, false, [
    'tests'
]);

/**
 * Generate Test Stats
 * Get statistics about tests
 */
export const generateTestStatsTestsStatsGetOptions = (options?: Options<GenerateTestStatsTestsStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateTestStatsTestsStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateTestStatsTestsStatsGetQueryKey(options)
    });
};

export const getIndividualTestStatisticsTestsTestIdStatsGetQueryKey = (options: Options<GetIndividualTestStatisticsTestsTestIdStatsGetData>) => createQueryKey('getIndividualTestStatisticsTestsTestIdStatsGet', options, false, [
    'tests'
]);

/**
 * Get Individual Test Statistics
 * Get comprehensive statistics for a specific test across all its test runs.
 *
 * Provides:
 * - Overall pass/fail statistics
 * - Per-metric breakdown of success rates
 * - Recent test run details with per-metric results
 * - Average execution time
 *
 * Query Parameters:
 * - recent_runs_limit: Number of recent test runs to include (default: 5)
 * - months: Filter to last N months of data (optional)
 * - start_date: Custom start date in ISO format (optional, overrides months)
 * - end_date: Custom end date in ISO format (optional, overrides months)
 *
 * Example usage:
 * - GET /tests/{test_id}/stats
 * - GET /tests/{test_id}/stats?recent_runs_limit=10
 * - GET /tests/{test_id}/stats?months=3
 * - GET /tests/{test_id}/stats?start_date=2024-01-01&end_date=2024-12-31
 */
export const getIndividualTestStatisticsTestsTestIdStatsGetOptions = (options: Options<GetIndividualTestStatisticsTestsTestIdStatsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIndividualTestStatisticsTestsTestIdStatsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getIndividualTestStatisticsTestsTestIdStatsGetQueryKey(options)
    });
};

/**
 * Delete Test
 * Delete a test
 */
export const deleteTestTestsTestIdDeleteMutation = (options?: Partial<Options<DeleteTestTestsTestIdDeleteData>>): UseMutationOptions<DeleteTestTestsTestIdDeleteResponse, DeleteTestTestsTestIdDeleteError, Options<DeleteTestTestsTestIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTestTestsTestIdDeleteResponse, DeleteTestTestsTestIdDeleteError, Options<DeleteTestTestsTestIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTestTestsTestIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTestTestsTestIdGetQueryKey = (options: Options<ReadTestTestsTestIdGetData>) => createQueryKey('readTestTestsTestIdGet', options, false, [
    'tests'
]);

/**
 * Read Test
 * Get a specific test by ID with its related objects
 */
export const readTestTestsTestIdGetOptions = (options: Options<ReadTestTestsTestIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTestTestsTestIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTestTestsTestIdGetQueryKey(options)
    });
};

/**
 * Update Test
 * Update test with optimized approach - no session variables needed.
 *
 * Performance improvements:
 * - Completely bypasses database session variables
 * - No SET LOCAL commands needed
 * - No SHOW queries during update
 * - Direct tenant context injection
 */
export const updateTestTestsTestIdPutMutation = (options?: Partial<Options<UpdateTestTestsTestIdPutData>>): UseMutationOptions<UpdateTestTestsTestIdPutResponse, UpdateTestTestsTestIdPutError, Options<UpdateTestTestsTestIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTestTestsTestIdPutResponse, UpdateTestTestsTestIdPutError, Options<UpdateTestTestsTestIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTestTestsTestIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTokensTokensGetQueryKey = (options?: Options<ReadTokensTokensGetData>) => createQueryKey('readTokensTokensGet', options, false, [
    'tokens'
]);

/**
 * Read Tokens
 * List all active API tokens for the current user.
 */
export const readTokensTokensGetOptions = (options?: Options<ReadTokensTokensGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTokensTokensGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTokensTokensGetQueryKey(options)
    });
};

/**
 * Create Token
 * Create a new API token for the current user.
 */
export const createTokenTokensPostMutation = (options?: Partial<Options<CreateTokenTokensPostData>>): UseMutationOptions<CreateTokenTokensPostResponse, CreateTokenTokensPostError, Options<CreateTokenTokensPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTokenTokensPostResponse, CreateTokenTokensPostError, Options<CreateTokenTokensPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTokenTokensPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Token
 * Revoke (delete) a token.
 */
export const deleteTokenTokensTokenIdDeleteMutation = (options?: Partial<Options<DeleteTokenTokensTokenIdDeleteData>>): UseMutationOptions<DeleteTokenTokensTokenIdDeleteResponse, DeleteTokenTokensTokenIdDeleteError, Options<DeleteTokenTokensTokenIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTokenTokensTokenIdDeleteResponse, DeleteTokenTokensTokenIdDeleteError, Options<DeleteTokenTokensTokenIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTokenTokensTokenIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTokenTokensTokenIdGetQueryKey = (options: Options<ReadTokenTokensTokenIdGetData>) => createQueryKey('readTokenTokensTokenIdGet', options, false, [
    'tokens'
]);

/**
 * Read Token
 * Get a specific token by ID.
 */
export const readTokenTokensTokenIdGetOptions = (options: Options<ReadTokenTokensTokenIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTokenTokensTokenIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTokenTokensTokenIdGetQueryKey(options)
    });
};

/**
 * Update Token
 * Update token metadata (e.g., name or expiry).
 */
export const updateTokenTokensTokenIdPutMutation = (options?: Partial<Options<UpdateTokenTokensTokenIdPutData>>): UseMutationOptions<UpdateTokenTokensTokenIdPutResponse, UpdateTokenTokensTokenIdPutError, Options<UpdateTokenTokensTokenIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTokenTokensTokenIdPutResponse, UpdateTokenTokensTokenIdPutError, Options<UpdateTokenTokensTokenIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTokenTokensTokenIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh Token
 * Refresh a token with a new value (rotate the secret) and optional new expiration.
 */
export const refreshTokenTokensTokenIdRefreshPostMutation = (options?: Partial<Options<RefreshTokenTokensTokenIdRefreshPostData>>): UseMutationOptions<RefreshTokenTokensTokenIdRefreshPostResponse, RefreshTokenTokensTokenIdRefreshPostError, Options<RefreshTokenTokensTokenIdRefreshPostData>> => {
    const mutationOptions: UseMutationOptions<RefreshTokenTokensTokenIdRefreshPostResponse, RefreshTokenTokensTokenIdRefreshPostError, Options<RefreshTokenTokensTokenIdRefreshPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await refreshTokenTokensTokenIdRefreshPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTopicsTopicsGetQueryKey = (options?: Options<ReadTopicsTopicsGetData>) => createQueryKey('readTopicsTopicsGet', options, false, [
    'topics'
]);

/**
 * Read Topics
 * Get all topics with their related objects
 */
export const readTopicsTopicsGetOptions = (options?: Options<ReadTopicsTopicsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTopicsTopicsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTopicsTopicsGetQueryKey(options)
    });
};

/**
 * Create Topic
 * Create topic with optimized approach - no session variables needed.
 */
export const createTopicTopicsPostMutation = (options?: Partial<Options<CreateTopicTopicsPostData>>): UseMutationOptions<CreateTopicTopicsPostResponse, CreateTopicTopicsPostError, Options<CreateTopicTopicsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTopicTopicsPostResponse, CreateTopicTopicsPostError, Options<CreateTopicTopicsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTopicTopicsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Topic
 * Delete a topic.
 */
export const deleteTopicTopicsTopicIdDeleteMutation = (options?: Partial<Options<DeleteTopicTopicsTopicIdDeleteData>>): UseMutationOptions<DeleteTopicTopicsTopicIdDeleteResponse, DeleteTopicTopicsTopicIdDeleteError, Options<DeleteTopicTopicsTopicIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTopicTopicsTopicIdDeleteResponse, DeleteTopicTopicsTopicIdDeleteError, Options<DeleteTopicTopicsTopicIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTopicTopicsTopicIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTopicTopicsTopicIdGetQueryKey = (options: Options<ReadTopicTopicsTopicIdGetData>) => createQueryKey('readTopicTopicsTopicIdGet', options, false, [
    'topics'
]);

/**
 * Read Topic
 * Get a single topic by ID.
 */
export const readTopicTopicsTopicIdGetOptions = (options: Options<ReadTopicTopicsTopicIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTopicTopicsTopicIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTopicTopicsTopicIdGetQueryKey(options)
    });
};

/**
 * Update Topic
 * Update topic with optimized approach - no session variables needed.
 */
export const updateTopicTopicsTopicIdPutMutation = (options?: Partial<Options<UpdateTopicTopicsTopicIdPutData>>): UseMutationOptions<UpdateTopicTopicsTopicIdPutResponse, UpdateTopicTopicsTopicIdPutError, Options<UpdateTopicTopicsTopicIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTopicTopicsTopicIdPutResponse, UpdateTopicTopicsTopicIdPutError, Options<UpdateTopicTopicsTopicIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTopicTopicsTopicIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTypeLookupsTypeLookupsGetQueryKey = (options?: Options<ReadTypeLookupsTypeLookupsGetData>) => createQueryKey('readTypeLookupsTypeLookupsGet', options, false, [
    'type_lookups'
]);

/**
 * Read Type Lookups
 * Get all type lookups with their related objects
 */
export const readTypeLookupsTypeLookupsGetOptions = (options?: Options<ReadTypeLookupsTypeLookupsGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTypeLookupsTypeLookupsGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTypeLookupsTypeLookupsGetQueryKey(options)
    });
};

/**
 * Create Type Lookup
 * Create type lookup with optimized approach - no session variables needed.
 */
export const createTypeLookupTypeLookupsPostMutation = (options?: Partial<Options<CreateTypeLookupTypeLookupsPostData>>): UseMutationOptions<CreateTypeLookupTypeLookupsPostResponse, CreateTypeLookupTypeLookupsPostError, Options<CreateTypeLookupTypeLookupsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateTypeLookupTypeLookupsPostResponse, CreateTypeLookupTypeLookupsPostError, Options<CreateTypeLookupTypeLookupsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTypeLookupTypeLookupsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Type Lookup
 * Delete a type lookup with tenant scoping.
 */
export const deleteTypeLookupTypeLookupsTypeLookupIdDeleteMutation = (options?: Partial<Options<DeleteTypeLookupTypeLookupsTypeLookupIdDeleteData>>): UseMutationOptions<DeleteTypeLookupTypeLookupsTypeLookupIdDeleteResponse, DeleteTypeLookupTypeLookupsTypeLookupIdDeleteError, Options<DeleteTypeLookupTypeLookupsTypeLookupIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteTypeLookupTypeLookupsTypeLookupIdDeleteResponse, DeleteTypeLookupTypeLookupsTypeLookupIdDeleteError, Options<DeleteTypeLookupTypeLookupsTypeLookupIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTypeLookupTypeLookupsTypeLookupIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readTypeLookupTypeLookupsTypeLookupIdGetQueryKey = (options: Options<ReadTypeLookupTypeLookupsTypeLookupIdGetData>) => createQueryKey('readTypeLookupTypeLookupsTypeLookupIdGet', options, false, [
    'type_lookups'
]);

/**
 * Read Type Lookup
 * Get a single type lookup by ID with tenant scoping.
 */
export const readTypeLookupTypeLookupsTypeLookupIdGetOptions = (options: Options<ReadTypeLookupTypeLookupsTypeLookupIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readTypeLookupTypeLookupsTypeLookupIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readTypeLookupTypeLookupsTypeLookupIdGetQueryKey(options)
    });
};

/**
 * Update Type Lookup
 * Update a type lookup with tenant scoping.
 */
export const updateTypeLookupTypeLookupsTypeLookupIdPutMutation = (options?: Partial<Options<UpdateTypeLookupTypeLookupsTypeLookupIdPutData>>): UseMutationOptions<UpdateTypeLookupTypeLookupsTypeLookupIdPutResponse, UpdateTypeLookupTypeLookupsTypeLookupIdPutError, Options<UpdateTypeLookupTypeLookupsTypeLookupIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateTypeLookupTypeLookupsTypeLookupIdPutResponse, UpdateTypeLookupTypeLookupsTypeLookupIdPutError, Options<UpdateTypeLookupTypeLookupsTypeLookupIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTypeLookupTypeLookupsTypeLookupIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUseCasesUseCasesGetQueryKey = (options?: Options<ReadUseCasesUseCasesGetData>) => createQueryKey('readUseCasesUseCasesGet', options, false, [
    'use_cases'
]);

/**
 * Read Use Cases
 * Get all use cases with their related objects
 */
export const readUseCasesUseCasesGetOptions = (options?: Options<ReadUseCasesUseCasesGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUseCasesUseCasesGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUseCasesUseCasesGetQueryKey(options)
    });
};

/**
 * Create Use Case
 * Create use case with optimized approach - no session variables needed.
 */
export const createUseCaseUseCasesPostMutation = (options?: Partial<Options<CreateUseCaseUseCasesPostData>>): UseMutationOptions<CreateUseCaseUseCasesPostResponse, CreateUseCaseUseCasesPostError, Options<CreateUseCaseUseCasesPostData>> => {
    const mutationOptions: UseMutationOptions<CreateUseCaseUseCasesPostResponse, CreateUseCaseUseCasesPostError, Options<CreateUseCaseUseCasesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createUseCaseUseCasesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Use Case
 * Delete a use case with tenant scoping.
 */
export const deleteUseCaseUseCasesUseCaseIdDeleteMutation = (options?: Partial<Options<DeleteUseCaseUseCasesUseCaseIdDeleteData>>): UseMutationOptions<DeleteUseCaseUseCasesUseCaseIdDeleteResponse, DeleteUseCaseUseCasesUseCaseIdDeleteError, Options<DeleteUseCaseUseCasesUseCaseIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteUseCaseUseCasesUseCaseIdDeleteResponse, DeleteUseCaseUseCasesUseCaseIdDeleteError, Options<DeleteUseCaseUseCasesUseCaseIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUseCaseUseCasesUseCaseIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUseCaseUseCasesUseCaseIdGetQueryKey = (options: Options<ReadUseCaseUseCasesUseCaseIdGetData>) => createQueryKey('readUseCaseUseCasesUseCaseIdGet', options, false, [
    'use_cases'
]);

/**
 * Read Use Case
 * Get a single use case by ID with tenant scoping.
 */
export const readUseCaseUseCasesUseCaseIdGetOptions = (options: Options<ReadUseCaseUseCasesUseCaseIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUseCaseUseCasesUseCaseIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUseCaseUseCasesUseCaseIdGetQueryKey(options)
    });
};

/**
 * Update Use Case
 * Update a use case with tenant scoping.
 */
export const updateUseCaseUseCasesUseCaseIdPutMutation = (options?: Partial<Options<UpdateUseCaseUseCasesUseCaseIdPutData>>): UseMutationOptions<UpdateUseCaseUseCasesUseCaseIdPutResponse, UpdateUseCaseUseCasesUseCaseIdPutError, Options<UpdateUseCaseUseCasesUseCaseIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateUseCaseUseCasesUseCaseIdPutResponse, UpdateUseCaseUseCasesUseCaseIdPutError, Options<UpdateUseCaseUseCasesUseCaseIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUseCaseUseCasesUseCaseIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUsersUsersGetQueryKey = (options?: Options<ReadUsersUsersGetData>) => createQueryKey('readUsersUsersGet', options, false, [
    'users'
]);

/**
 * Read Users
 * Get all users for the tenant with filtering and paging.
 */
export const readUsersUsersGetOptions = (options?: Options<ReadUsersUsersGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUsersUsersGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUsersUsersGetQueryKey(options)
    });
};

/**
 * Create User
 * Invite or create a user within the current user's organization.
 * - If a user with the same email exists but has no organization, re-invite (re-attach) them.
 * - If they belong to another organization, return 409.
 */
export const createUserUsersPostMutation = (options?: Partial<Options<CreateUserUsersPostData>>): UseMutationOptions<CreateUserUsersPostResponse, CreateUserUsersPostError, Options<CreateUserUsersPostData>> => {
    const mutationOptions: UseMutationOptions<CreateUserUsersPostResponse, CreateUserUsersPostError, Options<CreateUserUsersPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createUserUsersPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 * Delete a user (superusers only, tenant-scoped).
 */
export const deleteUserUsersUserIdDeleteMutation = (options?: Partial<Options<DeleteUserUsersUserIdDeleteData>>): UseMutationOptions<DeleteUserUsersUserIdDeleteResponse, DeleteUserUsersUserIdDeleteError, Options<DeleteUserUsersUserIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserUsersUserIdDeleteResponse, DeleteUserUsersUserIdDeleteError, Options<DeleteUserUsersUserIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUserUsersUserIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUserUsersUserIdGetQueryKey = (options: Options<ReadUserUsersUserIdGetData>) => createQueryKey('readUserUsersUserIdGet', options, false, [
    'users'
]);

/**
 * Read User
 * Get a specific user by ID (tenant-scoped).
 */
export const readUserUsersUserIdGetOptions = (options: Options<ReadUserUsersUserIdGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUserUsersUserIdGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUserUsersUserIdGetQueryKey(options)
    });
};

/**
 * Update User
 * Update a user profile. If the current user updates their own profile, include a new session token.
 *
 * Returns:
 * UserUpdateResponse: {"user": User, "session_token": str | None}
 */
export const updateUserUsersUserIdPutMutation = (options?: Partial<Options<UpdateUserUsersUserIdPutData>>): UseMutationOptions<UpdateUserUsersUserIdPutResponse, UpdateUserUsersUserIdPutError, Options<UpdateUserUsersUserIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserUsersUserIdPutResponse, UpdateUserUsersUserIdPutError, Options<UpdateUserUsersUserIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserUsersUserIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Leave Organization
 * Allow the current user to leave their organization (sets organization_id to NULL).
 */
export const leaveOrganizationUsersLeaveOrganizationPatchMutation = (options?: Partial<Options<LeaveOrganizationUsersLeaveOrganizationPatchData>>): UseMutationOptions<LeaveOrganizationUsersLeaveOrganizationPatchResponse, DefaultError, Options<LeaveOrganizationUsersLeaveOrganizationPatchData>> => {
    const mutationOptions: UseMutationOptions<LeaveOrganizationUsersLeaveOrganizationPatchResponse, DefaultError, Options<LeaveOrganizationUsersLeaveOrganizationPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await leaveOrganizationUsersLeaveOrganizationPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rootGetQueryKey = (options?: Options<RootGetData>) => createQueryKey('rootGet', options);

/**
 * Root
 * Welcome endpoint with API status
 */
export const rootGetOptions = (options?: Options<RootGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await rootGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: rootGetQueryKey(options)
    });
};
